{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CirtusAI Python SDK The Trust Layer for the Agent Economy - v0.2.2 (beta) A comprehensive Python SDK for building autonomous AI agents with blockchain-level security, multi-chain wallets, and enterprise compliance features. Learn more at cirtusai.com or view source on GitHub . Installation pip install cirtusai-sdk Quick Start from cirtusai import CirtusAIClient # Initialize client and authenticate client = CirtusAIClient(\"https://api.cirtusai.com\") token = client.auth.login_with_2fa(\"username\", \"password\", \"123456\") client.set_token(token.access_token) # Create an agent and provision email agent = client.agents.create_child_agent( parent_id=\"master_agent_id\", name=\"My Agent\", permissions_granted=[\"email:read\", \"email:send\"] ) email_asset = client.agents.provision_email(agent['id']) Documentation Quick Start Guide Authentication Guide Agent Management Wallet Operations Email Services Security & Compliance Blockchain Infrastructure","title":"Home"},{"location":"#cirtusai-python-sdk","text":"The Trust Layer for the Agent Economy - v0.2.2 (beta) A comprehensive Python SDK for building autonomous AI agents with blockchain-level security, multi-chain wallets, and enterprise compliance features. Learn more at cirtusai.com or view source on GitHub .","title":"CirtusAI Python SDK"},{"location":"#installation","text":"pip install cirtusai-sdk","title":"Installation"},{"location":"#quick-start","text":"from cirtusai import CirtusAIClient # Initialize client and authenticate client = CirtusAIClient(\"https://api.cirtusai.com\") token = client.auth.login_with_2fa(\"username\", \"password\", \"123456\") client.set_token(token.access_token) # Create an agent and provision email agent = client.agents.create_child_agent( parent_id=\"master_agent_id\", name=\"My Agent\", permissions_granted=[\"email:read\", \"email:send\"] ) email_asset = client.agents.provision_email(agent['id'])","title":"Quick Start"},{"location":"#documentation","text":"Quick Start Guide Authentication Guide Agent Management Wallet Operations Email Services Security & Compliance Blockchain Infrastructure","title":"Documentation"},{"location":"agents/","text":"CirtusAI SDK Agent Management Guide Overview The CirtusAI SDK provides comprehensive agent management capabilities for both master and child agents. The agent system enables hierarchical agent architectures with granular permission management and asset provisioning. Features Master Agent Management : Core agent lifecycle operations Child Agent Creation : Hierarchical agent structures Permission Management : Granular access control for child agents Asset Provisioning : Automated email and wallet provisioning Agent Linking : Parent-child relationship management Agent Types Master Agents Primary user agents with full permissions Can create and manage child agents Have direct API access and authentication Child Agents Subordinate agents with limited, delegated permissions Created and managed by master agents Inherit specific permissions from parent Can have assets (email, wallets) provisioned automatically Basic Agent Operations List All Agents from cirtusai import CirtusAIClient client = CirtusAIClient(\"https://api.cirtusai.com\") client.set_token(\"your_access_token\") # List all master agents for logged-in user agents = client.agents.list_agents() for agent in agents: print(f\"Agent ID: {agent['id']}\") print(f\"Name: {agent['name']}\") print(f\"Status: {agent['status']}\") Get Specific Agent # Retrieve specific agent details agent_id = \"agent_123\" agent = client.agents.get_agent(agent_id) print(f\"Agent Type: {agent['type']}\") print(f\"Permissions: {agent.get('permissions_granted', [])}\") print(f\"Created: {agent['created_at']}\") Delete Agent # Delete an agent (master or child) client.agents.delete_agent(\"agent_123\") print(\"Agent deleted successfully\") Child Agent Management Create Child Agent # Create a new child agent with specific permissions child_agent = client.agents.create_child_agent( parent_id=\"master_agent_123\", name=\"Email Processing Agent\", permissions_granted=[\"email:read\", \"email:send\"] ) print(f\"Child Agent ID: {child_agent['id']}\") print(f\"Parent ID: {child_agent['parent_id']}\") print(f\"Permissions: {child_agent['permissions_granted']}\") List Child Agents # Get all child agents for the current master agent children = client.agents.get_children() for child in children: print(f\"Child ID: {child['id']}\") print(f\"Name: {child['name']}\") print(f\"Permissions: {child['permissions_granted']}\") Update Child Permissions # Update permissions for a child agent new_permissions = { \"email:read\": True, \"email:send\": True, \"wallet:read\": True, \"wallet:send\": False } updated_agent = client.agents.update_child_permissions( child_id=\"child_agent_456\", permissions=new_permissions ) print(f\"Updated permissions: {updated_agent['permissions']}\") Unlink Child Agent # Remove/delete a child agent client.agents.unlink_child_agent(\"child_agent_456\") print(\"Child agent unlinked successfully\") Asset Provisioning Provision Email Assets # Automatically provision email capability for a child agent email_asset = client.agents.provision_email(\"child_agent_456\") print(f\"Email provisioned: {email_asset['email_address']}\") print(f\"Provider: {email_asset['provider']}\") print(f\"Status: {email_asset['status']}\") Provision Wallet Assets # Provision crypto wallet for child agent wallet_asset = client.agents.provision_wallet( agent_id=\"child_agent_456\", chain=\"ethereum\" # or \"polygon\", \"arbitrum\", etc. ) print(f\"Wallet Address: {wallet_asset['address']}\") print(f\"Chain: {wallet_asset['chain']}\") print(f\"Balance: {wallet_asset['balance']}\") Advanced Agent Workflows Multi-Purpose Agent Creation def create_comprehensive_agent(client, parent_id, name): \"\"\"Create a child agent with email and wallet capabilities\"\"\" # Step 1: Create child agent child = client.agents.create_child_agent( parent_id=parent_id, name=name, permissions_granted=[ \"email:read\", \"email:send\", \"wallet:read\", \"wallet:send\" ] ) child_id = child['id'] print(f\"Created child agent: {child_id}\") # Step 2: Provision email try: email_asset = client.agents.provision_email(child_id) print(f\"Email provisioned: {email_asset['email_address']}\") except Exception as e: print(f\"Email provisioning failed: {e}\") # Step 3: Provision wallet try: wallet_asset = client.agents.provision_wallet(child_id, \"ethereum\") print(f\"Wallet provisioned: {wallet_asset['address']}\") except Exception as e: print(f\"Wallet provisioning failed: {e}\") return child # Usage master_agent_id = \"master_123\" agent = create_comprehensive_agent( client, master_agent_id, \"Trading Assistant Agent\" ) Agent Permission Matrix def setup_permission_matrix(client, child_id, role): \"\"\"Setup permissions based on agent role\"\"\" permission_templates = { \"email_only\": { \"email:read\": True, \"email:send\": True, \"wallet:read\": False, \"wallet:send\": False }, \"wallet_only\": { \"email:read\": False, \"email:send\": False, \"wallet:read\": True, \"wallet:send\": True }, \"full_access\": { \"email:read\": True, \"email:send\": True, \"wallet:read\": True, \"wallet:send\": True }, \"read_only\": { \"email:read\": True, \"email:send\": False, \"wallet:read\": True, \"wallet:send\": False } } permissions = permission_templates.get(role, permission_templates[\"read_only\"]) return client.agents.update_child_permissions(child_id, permissions) # Usage examples setup_permission_matrix(client, \"child_123\", \"email_only\") setup_permission_matrix(client, \"child_456\", \"full_access\") Bulk Agent Management def create_agent_fleet(client, parent_id, agent_configs): \"\"\"Create multiple child agents with different configurations\"\"\" created_agents = [] for config in agent_configs: try: # Create child agent child = client.agents.create_child_agent( parent_id=parent_id, name=config[\"name\"], permissions_granted=config[\"permissions\"] ) # Provision assets based on config if config.get(\"needs_email\"): client.agents.provision_email(child['id']) if config.get(\"needs_wallet\"): client.agents.provision_wallet( child['id'], config.get(\"chain\", \"ethereum\") ) created_agents.append(child) print(f\"Created agent: {child['name']} ({child['id']})\") except Exception as e: print(f\"Failed to create agent {config['name']}: {e}\") return created_agents # Usage agent_configs = [ { \"name\": \"Email Monitor Agent\", \"permissions\": [\"email:read\"], \"needs_email\": True, \"needs_wallet\": False }, { \"name\": \"Trading Agent\", \"permissions\": [\"wallet:read\", \"wallet:send\"], \"needs_email\": False, \"needs_wallet\": True, \"chain\": \"ethereum\" }, { \"name\": \"Notification Agent\", \"permissions\": [\"email:read\", \"email:send\"], \"needs_email\": True, \"needs_wallet\": False } ] fleet = create_agent_fleet(client, \"master_123\", agent_configs) Agent Monitoring and Status Agent Health Check def check_agent_health(client, agent_id): \"\"\"Check agent status and asset health\"\"\" try: agent = client.agents.get_agent(agent_id) health_report = { \"agent_id\": agent_id, \"status\": agent.get(\"status\", \"unknown\"), \"permissions\": agent.get(\"permissions_granted\", []), \"assets\": { \"email\": False, \"wallet\": False } } # Check if agent has email capabilities if \"email:read\" in agent.get(\"permissions_granted\", []): try: # Try to access email client.email.read_inbox(agent_id) health_report[\"assets\"][\"email\"] = True except: health_report[\"assets\"][\"email\"] = False # Check if agent has wallet capabilities if \"wallet:read\" in agent.get(\"permissions_granted\", []): try: # Try to access wallet client.wallets.list_wallets() health_report[\"assets\"][\"wallet\"] = True except: health_report[\"assets\"][\"wallet\"] = False return health_report except Exception as e: return {\"agent_id\": agent_id, \"error\": str(e)} # Usage health = check_agent_health(client, \"child_agent_123\") print(f\"Agent Health: {health}\") Agent Activity Monitoring def monitor_agent_activity(client): \"\"\"Monitor all agent activity\"\"\" agents = client.agents.list_agents() children = client.agents.get_children() print(\"=== Agent Activity Report ===\") print(f\"Master Agents: {len(agents)}\") print(f\"Child Agents: {len(children)}\") for child in children: permissions = child.get('permissions_granted', []) print(f\"\\nChild Agent: {child['name']}\") print(f\" ID: {child['id']}\") print(f\" Permissions: {', '.join(permissions)}\") # Check recent activity (if available) health = check_agent_health(client, child['id']) print(f\" Email Active: {health['assets']['email']}\") print(f\" Wallet Active: {health['assets']['wallet']}\") # Usage monitor_agent_activity(client) Error Handling Common Error Scenarios def safe_agent_operation(client, operation, *args, **kwargs): \"\"\"Safely execute agent operations with error handling\"\"\" try: result = getattr(client.agents, operation)(*args, **kwargs) return {\"success\": True, \"result\": result} except requests.exceptions.HTTPError as e: if e.response.status_code == 403: return {\"success\": False, \"error\": \"Permission denied\"} elif e.response.status_code == 404: return {\"success\": False, \"error\": \"Agent not found\"} else: return {\"success\": False, \"error\": f\"HTTP error: {e}\"} except Exception as e: return {\"success\": False, \"error\": f\"Unexpected error: {e}\"} # Usage examples result = safe_agent_operation(client, \"get_agent\", \"invalid_agent_id\") if not result[\"success\"]: print(f\"Operation failed: {result['error']}\") Best Practices 1. Agent Naming Convention def generate_agent_name(purpose, environment=\"prod\"): \"\"\"Generate standardized agent names\"\"\" timestamp = datetime.now().strftime(\"%Y%m%d\") return f\"{environment}_{purpose}_{timestamp}\" # Examples email_agent = generate_agent_name(\"email_processor\", \"dev\") trading_agent = generate_agent_name(\"trading_bot\", \"prod\") 2. Permission Management class PermissionManager: \"\"\"Manage agent permissions systematically\"\"\" PERMISSION_LEVELS = { \"minimal\": [\"email:read\"], \"standard\": [\"email:read\", \"email:send\"], \"advanced\": [\"email:read\", \"email:send\", \"wallet:read\"], \"full\": [\"email:read\", \"email:send\", \"wallet:read\", \"wallet:send\"] } @classmethod def get_permissions(cls, level): return cls.PERMISSION_LEVELS.get(level, cls.PERMISSION_LEVELS[\"minimal\"]) @classmethod def validate_permissions(cls, permissions): valid_permissions = [ \"email:read\", \"email:send\", \"wallet:read\", \"wallet:send\" ] return all(perm in valid_permissions for perm in permissions) # Usage permissions = PermissionManager.get_permissions(\"standard\") child = client.agents.create_child_agent( parent_id=\"master_123\", name=\"Standard Agent\", permissions_granted=permissions ) 3. Asset Lifecycle Management class AgentAssetManager: \"\"\"Manage agent assets throughout lifecycle\"\"\" def __init__(self, client): self.client = client def setup_complete_agent(self, parent_id, name, needs_email=True, needs_wallet=True): \"\"\"Setup agent with all required assets\"\"\" # Determine permissions based on needs permissions = [] if needs_email: permissions.extend([\"email:read\", \"email:send\"]) if needs_wallet: permissions.extend([\"wallet:read\", \"wallet:send\"]) # Create agent agent = self.client.agents.create_child_agent( parent_id=parent_id, name=name, permissions_granted=permissions ) agent_id = agent['id'] # Provision assets if needs_email: self.client.agents.provision_email(agent_id) if needs_wallet: self.client.agents.provision_wallet(agent_id) return agent def cleanup_agent(self, agent_id): \"\"\"Clean up agent and its assets\"\"\" try: self.client.agents.unlink_child_agent(agent_id) return True except Exception as e: print(f\"Cleanup failed: {e}\") return False # Usage manager = AgentAssetManager(client) agent = manager.setup_complete_agent( parent_id=\"master_123\", name=\"Complete Agent\", needs_email=True, needs_wallet=True ) API Reference AgentsClient Methods Method Description Parameters Returns list_agents() List all master agents - List[Dict] get_agent() Get specific agent details agent_id Dict create_child_agent() Create new child agent parent_id, name, permissions_granted Dict delete_agent() Delete agent agent_id None provision_email() Provision email for child agent agent_id Dict provision_wallet() Provision wallet for child agent agent_id, chain Dict get_children() List all child agents - List[Dict] update_child_permissions() Update child permissions child_id, permissions Dict unlink_child_agent() Remove child agent child_id None Agent Object Structure { \"id\": \"agent_123\", \"name\": \"My Agent\", \"type\": \"master\" | \"child\", \"status\": \"active\" | \"inactive\", \"parent_id\": \"master_123\", # for child agents \"permissions_granted\": [\"email:read\", \"email:send\"], \"created_at\": \"2024-01-01T00:00:00Z\", \"updated_at\": \"2024-01-01T00:00:00Z\" } Available Permissions email:read - Read email messages email:send - Send email messages wallet:read - View wallet balances and transactions wallet:send - Execute wallet transactions","title":"Agent Management"},{"location":"agents/#cirtusai-sdk-agent-management-guide","text":"","title":"CirtusAI SDK Agent Management Guide"},{"location":"agents/#overview","text":"The CirtusAI SDK provides comprehensive agent management capabilities for both master and child agents. The agent system enables hierarchical agent architectures with granular permission management and asset provisioning.","title":"Overview"},{"location":"agents/#features","text":"Master Agent Management : Core agent lifecycle operations Child Agent Creation : Hierarchical agent structures Permission Management : Granular access control for child agents Asset Provisioning : Automated email and wallet provisioning Agent Linking : Parent-child relationship management","title":"Features"},{"location":"agents/#agent-types","text":"","title":"Agent Types"},{"location":"agents/#master-agents","text":"Primary user agents with full permissions Can create and manage child agents Have direct API access and authentication","title":"Master Agents"},{"location":"agents/#child-agents","text":"Subordinate agents with limited, delegated permissions Created and managed by master agents Inherit specific permissions from parent Can have assets (email, wallets) provisioned automatically","title":"Child Agents"},{"location":"agents/#basic-agent-operations","text":"","title":"Basic Agent Operations"},{"location":"agents/#list-all-agents","text":"from cirtusai import CirtusAIClient client = CirtusAIClient(\"https://api.cirtusai.com\") client.set_token(\"your_access_token\") # List all master agents for logged-in user agents = client.agents.list_agents() for agent in agents: print(f\"Agent ID: {agent['id']}\") print(f\"Name: {agent['name']}\") print(f\"Status: {agent['status']}\")","title":"List All Agents"},{"location":"agents/#get-specific-agent","text":"# Retrieve specific agent details agent_id = \"agent_123\" agent = client.agents.get_agent(agent_id) print(f\"Agent Type: {agent['type']}\") print(f\"Permissions: {agent.get('permissions_granted', [])}\") print(f\"Created: {agent['created_at']}\")","title":"Get Specific Agent"},{"location":"agents/#delete-agent","text":"# Delete an agent (master or child) client.agents.delete_agent(\"agent_123\") print(\"Agent deleted successfully\")","title":"Delete Agent"},{"location":"agents/#child-agent-management","text":"","title":"Child Agent Management"},{"location":"agents/#create-child-agent","text":"# Create a new child agent with specific permissions child_agent = client.agents.create_child_agent( parent_id=\"master_agent_123\", name=\"Email Processing Agent\", permissions_granted=[\"email:read\", \"email:send\"] ) print(f\"Child Agent ID: {child_agent['id']}\") print(f\"Parent ID: {child_agent['parent_id']}\") print(f\"Permissions: {child_agent['permissions_granted']}\")","title":"Create Child Agent"},{"location":"agents/#list-child-agents","text":"# Get all child agents for the current master agent children = client.agents.get_children() for child in children: print(f\"Child ID: {child['id']}\") print(f\"Name: {child['name']}\") print(f\"Permissions: {child['permissions_granted']}\")","title":"List Child Agents"},{"location":"agents/#update-child-permissions","text":"# Update permissions for a child agent new_permissions = { \"email:read\": True, \"email:send\": True, \"wallet:read\": True, \"wallet:send\": False } updated_agent = client.agents.update_child_permissions( child_id=\"child_agent_456\", permissions=new_permissions ) print(f\"Updated permissions: {updated_agent['permissions']}\")","title":"Update Child Permissions"},{"location":"agents/#unlink-child-agent","text":"# Remove/delete a child agent client.agents.unlink_child_agent(\"child_agent_456\") print(\"Child agent unlinked successfully\")","title":"Unlink Child Agent"},{"location":"agents/#asset-provisioning","text":"","title":"Asset Provisioning"},{"location":"agents/#provision-email-assets","text":"# Automatically provision email capability for a child agent email_asset = client.agents.provision_email(\"child_agent_456\") print(f\"Email provisioned: {email_asset['email_address']}\") print(f\"Provider: {email_asset['provider']}\") print(f\"Status: {email_asset['status']}\")","title":"Provision Email Assets"},{"location":"agents/#provision-wallet-assets","text":"# Provision crypto wallet for child agent wallet_asset = client.agents.provision_wallet( agent_id=\"child_agent_456\", chain=\"ethereum\" # or \"polygon\", \"arbitrum\", etc. ) print(f\"Wallet Address: {wallet_asset['address']}\") print(f\"Chain: {wallet_asset['chain']}\") print(f\"Balance: {wallet_asset['balance']}\")","title":"Provision Wallet Assets"},{"location":"agents/#advanced-agent-workflows","text":"","title":"Advanced Agent Workflows"},{"location":"agents/#multi-purpose-agent-creation","text":"def create_comprehensive_agent(client, parent_id, name): \"\"\"Create a child agent with email and wallet capabilities\"\"\" # Step 1: Create child agent child = client.agents.create_child_agent( parent_id=parent_id, name=name, permissions_granted=[ \"email:read\", \"email:send\", \"wallet:read\", \"wallet:send\" ] ) child_id = child['id'] print(f\"Created child agent: {child_id}\") # Step 2: Provision email try: email_asset = client.agents.provision_email(child_id) print(f\"Email provisioned: {email_asset['email_address']}\") except Exception as e: print(f\"Email provisioning failed: {e}\") # Step 3: Provision wallet try: wallet_asset = client.agents.provision_wallet(child_id, \"ethereum\") print(f\"Wallet provisioned: {wallet_asset['address']}\") except Exception as e: print(f\"Wallet provisioning failed: {e}\") return child # Usage master_agent_id = \"master_123\" agent = create_comprehensive_agent( client, master_agent_id, \"Trading Assistant Agent\" )","title":"Multi-Purpose Agent Creation"},{"location":"agents/#agent-permission-matrix","text":"def setup_permission_matrix(client, child_id, role): \"\"\"Setup permissions based on agent role\"\"\" permission_templates = { \"email_only\": { \"email:read\": True, \"email:send\": True, \"wallet:read\": False, \"wallet:send\": False }, \"wallet_only\": { \"email:read\": False, \"email:send\": False, \"wallet:read\": True, \"wallet:send\": True }, \"full_access\": { \"email:read\": True, \"email:send\": True, \"wallet:read\": True, \"wallet:send\": True }, \"read_only\": { \"email:read\": True, \"email:send\": False, \"wallet:read\": True, \"wallet:send\": False } } permissions = permission_templates.get(role, permission_templates[\"read_only\"]) return client.agents.update_child_permissions(child_id, permissions) # Usage examples setup_permission_matrix(client, \"child_123\", \"email_only\") setup_permission_matrix(client, \"child_456\", \"full_access\")","title":"Agent Permission Matrix"},{"location":"agents/#bulk-agent-management","text":"def create_agent_fleet(client, parent_id, agent_configs): \"\"\"Create multiple child agents with different configurations\"\"\" created_agents = [] for config in agent_configs: try: # Create child agent child = client.agents.create_child_agent( parent_id=parent_id, name=config[\"name\"], permissions_granted=config[\"permissions\"] ) # Provision assets based on config if config.get(\"needs_email\"): client.agents.provision_email(child['id']) if config.get(\"needs_wallet\"): client.agents.provision_wallet( child['id'], config.get(\"chain\", \"ethereum\") ) created_agents.append(child) print(f\"Created agent: {child['name']} ({child['id']})\") except Exception as e: print(f\"Failed to create agent {config['name']}: {e}\") return created_agents # Usage agent_configs = [ { \"name\": \"Email Monitor Agent\", \"permissions\": [\"email:read\"], \"needs_email\": True, \"needs_wallet\": False }, { \"name\": \"Trading Agent\", \"permissions\": [\"wallet:read\", \"wallet:send\"], \"needs_email\": False, \"needs_wallet\": True, \"chain\": \"ethereum\" }, { \"name\": \"Notification Agent\", \"permissions\": [\"email:read\", \"email:send\"], \"needs_email\": True, \"needs_wallet\": False } ] fleet = create_agent_fleet(client, \"master_123\", agent_configs)","title":"Bulk Agent Management"},{"location":"agents/#agent-monitoring-and-status","text":"","title":"Agent Monitoring and Status"},{"location":"agents/#agent-health-check","text":"def check_agent_health(client, agent_id): \"\"\"Check agent status and asset health\"\"\" try: agent = client.agents.get_agent(agent_id) health_report = { \"agent_id\": agent_id, \"status\": agent.get(\"status\", \"unknown\"), \"permissions\": agent.get(\"permissions_granted\", []), \"assets\": { \"email\": False, \"wallet\": False } } # Check if agent has email capabilities if \"email:read\" in agent.get(\"permissions_granted\", []): try: # Try to access email client.email.read_inbox(agent_id) health_report[\"assets\"][\"email\"] = True except: health_report[\"assets\"][\"email\"] = False # Check if agent has wallet capabilities if \"wallet:read\" in agent.get(\"permissions_granted\", []): try: # Try to access wallet client.wallets.list_wallets() health_report[\"assets\"][\"wallet\"] = True except: health_report[\"assets\"][\"wallet\"] = False return health_report except Exception as e: return {\"agent_id\": agent_id, \"error\": str(e)} # Usage health = check_agent_health(client, \"child_agent_123\") print(f\"Agent Health: {health}\")","title":"Agent Health Check"},{"location":"agents/#agent-activity-monitoring","text":"def monitor_agent_activity(client): \"\"\"Monitor all agent activity\"\"\" agents = client.agents.list_agents() children = client.agents.get_children() print(\"=== Agent Activity Report ===\") print(f\"Master Agents: {len(agents)}\") print(f\"Child Agents: {len(children)}\") for child in children: permissions = child.get('permissions_granted', []) print(f\"\\nChild Agent: {child['name']}\") print(f\" ID: {child['id']}\") print(f\" Permissions: {', '.join(permissions)}\") # Check recent activity (if available) health = check_agent_health(client, child['id']) print(f\" Email Active: {health['assets']['email']}\") print(f\" Wallet Active: {health['assets']['wallet']}\") # Usage monitor_agent_activity(client)","title":"Agent Activity Monitoring"},{"location":"agents/#error-handling","text":"","title":"Error Handling"},{"location":"agents/#common-error-scenarios","text":"def safe_agent_operation(client, operation, *args, **kwargs): \"\"\"Safely execute agent operations with error handling\"\"\" try: result = getattr(client.agents, operation)(*args, **kwargs) return {\"success\": True, \"result\": result} except requests.exceptions.HTTPError as e: if e.response.status_code == 403: return {\"success\": False, \"error\": \"Permission denied\"} elif e.response.status_code == 404: return {\"success\": False, \"error\": \"Agent not found\"} else: return {\"success\": False, \"error\": f\"HTTP error: {e}\"} except Exception as e: return {\"success\": False, \"error\": f\"Unexpected error: {e}\"} # Usage examples result = safe_agent_operation(client, \"get_agent\", \"invalid_agent_id\") if not result[\"success\"]: print(f\"Operation failed: {result['error']}\")","title":"Common Error Scenarios"},{"location":"agents/#best-practices","text":"","title":"Best Practices"},{"location":"agents/#1-agent-naming-convention","text":"def generate_agent_name(purpose, environment=\"prod\"): \"\"\"Generate standardized agent names\"\"\" timestamp = datetime.now().strftime(\"%Y%m%d\") return f\"{environment}_{purpose}_{timestamp}\" # Examples email_agent = generate_agent_name(\"email_processor\", \"dev\") trading_agent = generate_agent_name(\"trading_bot\", \"prod\")","title":"1. Agent Naming Convention"},{"location":"agents/#2-permission-management","text":"class PermissionManager: \"\"\"Manage agent permissions systematically\"\"\" PERMISSION_LEVELS = { \"minimal\": [\"email:read\"], \"standard\": [\"email:read\", \"email:send\"], \"advanced\": [\"email:read\", \"email:send\", \"wallet:read\"], \"full\": [\"email:read\", \"email:send\", \"wallet:read\", \"wallet:send\"] } @classmethod def get_permissions(cls, level): return cls.PERMISSION_LEVELS.get(level, cls.PERMISSION_LEVELS[\"minimal\"]) @classmethod def validate_permissions(cls, permissions): valid_permissions = [ \"email:read\", \"email:send\", \"wallet:read\", \"wallet:send\" ] return all(perm in valid_permissions for perm in permissions) # Usage permissions = PermissionManager.get_permissions(\"standard\") child = client.agents.create_child_agent( parent_id=\"master_123\", name=\"Standard Agent\", permissions_granted=permissions )","title":"2. Permission Management"},{"location":"agents/#3-asset-lifecycle-management","text":"class AgentAssetManager: \"\"\"Manage agent assets throughout lifecycle\"\"\" def __init__(self, client): self.client = client def setup_complete_agent(self, parent_id, name, needs_email=True, needs_wallet=True): \"\"\"Setup agent with all required assets\"\"\" # Determine permissions based on needs permissions = [] if needs_email: permissions.extend([\"email:read\", \"email:send\"]) if needs_wallet: permissions.extend([\"wallet:read\", \"wallet:send\"]) # Create agent agent = self.client.agents.create_child_agent( parent_id=parent_id, name=name, permissions_granted=permissions ) agent_id = agent['id'] # Provision assets if needs_email: self.client.agents.provision_email(agent_id) if needs_wallet: self.client.agents.provision_wallet(agent_id) return agent def cleanup_agent(self, agent_id): \"\"\"Clean up agent and its assets\"\"\" try: self.client.agents.unlink_child_agent(agent_id) return True except Exception as e: print(f\"Cleanup failed: {e}\") return False # Usage manager = AgentAssetManager(client) agent = manager.setup_complete_agent( parent_id=\"master_123\", name=\"Complete Agent\", needs_email=True, needs_wallet=True )","title":"3. Asset Lifecycle Management"},{"location":"agents/#api-reference","text":"","title":"API Reference"},{"location":"agents/#agentsclient-methods","text":"Method Description Parameters Returns list_agents() List all master agents - List[Dict] get_agent() Get specific agent details agent_id Dict create_child_agent() Create new child agent parent_id, name, permissions_granted Dict delete_agent() Delete agent agent_id None provision_email() Provision email for child agent agent_id Dict provision_wallet() Provision wallet for child agent agent_id, chain Dict get_children() List all child agents - List[Dict] update_child_permissions() Update child permissions child_id, permissions Dict unlink_child_agent() Remove child agent child_id None","title":"AgentsClient Methods"},{"location":"agents/#agent-object-structure","text":"{ \"id\": \"agent_123\", \"name\": \"My Agent\", \"type\": \"master\" | \"child\", \"status\": \"active\" | \"inactive\", \"parent_id\": \"master_123\", # for child agents \"permissions_granted\": [\"email:read\", \"email:send\"], \"created_at\": \"2024-01-01T00:00:00Z\", \"updated_at\": \"2024-01-01T00:00:00Z\" }","title":"Agent Object Structure"},{"location":"agents/#available-permissions","text":"email:read - Read email messages email:send - Send email messages wallet:read - View wallet balances and transactions wallet:send - Execute wallet transactions","title":"Available Permissions"},{"location":"authentication/","text":"CirtusAI SDK Authentication Guide Overview The CirtusAI SDK provides comprehensive authentication capabilities with robust Two-Factor Authentication (2FA) support. The authentication system supports TOTP-based 2FA, SMS verification (framework ready), and complete user lifecycle management. Features User Registration : Automatic 2FA setup during registration Two-Step Login Flow : Secure authentication for 2FA-enabled users TOTP Management : Complete TOTP setup, verification, and management SMS 2FA Support : Framework ready for SMS-based authentication Debug Tools : Troubleshooting and time sync verification tools Token Management : Access token refresh and lifecycle management Basic Authentication User Registration Register a new user with automatic 2FA setup: from cirtusai import CirtusAIClient client = CirtusAIClient(\"https://api.cirtusai.com\") # Register with automatic 2FA setup setup_response = client.auth.register( username=\"your_username\", email=\"your_email@example.com\", password=\"your_secure_password\", preferred_2fa_method=\"totp\" # or \"sms\" ) print(f\"QR Code URL: {setup_response.qr_code_url}\") print(f\"Secret Key: {setup_response.secret_key}\") print(f\"Backup Codes: {setup_response.backup_codes}\") Simple Login (No 2FA) For accounts without 2FA enabled: # Direct login without 2FA token = client.auth.login(\"username\", \"password\") client.set_token(token.access_token) Two-Factor Authentication Login with 2FA Method 1: Two-Step Process # Step 1: Initial login login_result = client.auth.login(\"username\", \"password\") if hasattr(login_result, 'requires_2fa') and login_result.requires_2fa: # Step 2: Verify 2FA totp_code = input(\"Enter TOTP code: \") token = client.auth.verify_2fa(login_result.temporary_token, totp_code) client.set_token(token.access_token) else: # No 2FA required client.set_token(login_result.access_token) Method 2: Single Method # Complete 2FA login in one call try: token = client.auth.login_with_2fa(\"username\", \"password\", \"123456\") client.set_token(token.access_token) print(\"Login successful!\") except TwoFactorAuthenticationError as e: print(f\"2FA verification failed: {e}\") 2FA Management Check 2FA Status status = client.auth.get_2fa_status() print(f\"2FA Enabled: {status.enabled}\") print(f\"Method: {status.method}\") print(f\"Backup Codes Available: {status.backup_codes_remaining}\") Setup 2FA for Existing User # Setup 2FA setup_response = client.auth.setup_2fa() print(f\"Scan this QR code: {setup_response.qr_code_url}\") # After scanning QR code, confirm with TOTP totp_code = input(\"Enter TOTP code from authenticator app: \") result = client.auth.confirm_2fa(totp_code) print(f\"2FA setup complete: {result}\") Disable 2FA # Disable 2FA (requires current TOTP code and password) totp_code = input(\"Enter current TOTP code: \") password = input(\"Enter your password: \") result = client.auth.disable_2fa(totp_code, password) print(f\"2FA disabled: {result}\") Get QR Code Image # Get QR code as PNG bytes qr_bytes = client.auth.get_qr_code() with open(\"qr_code.png\", \"wb\") as f: f.write(qr_bytes) SMS 2FA (Framework Ready) # Request SMS code (when implemented) result = client.auth.request_sms_code() print(f\"SMS sent: {result}\") Debugging and Troubleshooting Debug TOTP Issues # Debug TOTP setup and time sync debug_info = client.auth.debug_2fa() print(f\"Current valid codes: {debug_info.get('valid_codes')}\") print(f\"Server time: {debug_info.get('server_time')}\") print(f\"Time window: {debug_info.get('time_window')}\") Token Management Refresh Access Token # Refresh expired access token refresh_token = \"your_refresh_token\" new_tokens = client.auth.refresh(refresh_token) client.set_token(new_tokens[\"access_token\"]) Error Handling Custom Exception Handling from cirtusai.auth import TwoFactorAuthenticationError try: token = client.auth.login_with_2fa(\"username\", \"password\", \"invalid_code\") except TwoFactorAuthenticationError as e: print(f\"2FA Error: {e}\") except requests.exceptions.HTTPError as e: print(f\"HTTP Error: {e}\") Advanced Usage Complete Registration and Login Flow def complete_registration_flow(): client = CirtusAIClient(\"https://api.cirtusai.com\") # Register user setup = client.auth.register( username=\"new_user\", email=\"user@example.com\", password=\"secure_password\" ) print(\"Please scan this QR code with your authenticator app:\") print(setup.qr_code_url) # Wait for user to setup authenticator totp_code = input(\"Enter TOTP code to confirm setup: \") client.auth.confirm_2fa(totp_code) # Now login with 2FA token = client.auth.login_with_2fa(\"new_user\", \"secure_password\", totp_code) client.set_token(token.access_token) return client Session Management class AuthenticatedSession: def __init__(self, base_url, username, password): self.client = CirtusAIClient(base_url) self.username = username self.password = password self._authenticate() def _authenticate(self): login_result = self.client.auth.login(self.username, self.password) if hasattr(login_result, 'requires_2fa'): totp_code = input(\"Enter TOTP code: \") token = self.client.auth.verify_2fa( login_result.temporary_token, totp_code ) else: token = login_result self.client.set_token(token.access_token) def get_client(self): return self.client Security Best Practices 1. Secure Token Storage import keyring # Store tokens securely def store_token_securely(token): keyring.set_password(\"cirtusai\", \"access_token\", token) def get_stored_token(): return keyring.get_password(\"cirtusai\", \"access_token\") 2. Automatic Token Refresh def auto_refresh_client(client, refresh_token): try: # Attempt API call response = client.some_api_call() return response except requests.exceptions.HTTPError as e: if e.response.status_code == 401: # Token expired, refresh new_tokens = client.auth.refresh(refresh_token) client.set_token(new_tokens[\"access_token\"]) # Retry original call return client.some_api_call() raise 3. Backup Code Management def save_backup_codes(backup_codes): \"\"\"Save backup codes securely\"\"\" with open(\"backup_codes.txt\", \"w\") as f: f.write(\"CirtusAI Backup Codes (Store Securely):\\n\") for i, code in enumerate(backup_codes, 1): f.write(f\"{i}. {code}\\n\") print(\"Backup codes saved to backup_codes.txt - store this file securely!\") Configuration Environment Variables import os from cirtusai import CirtusAIClient # Configure using environment variables client = CirtusAIClient( base_url=os.getenv(\"CIRTUSAI_API_URL\", \"https://api.cirtusai.com\"), token=os.getenv(\"CIRTUSAI_ACCESS_TOKEN\") ) Configuration File import json def load_auth_config(config_file=\"cirtusai_config.json\"): with open(config_file) as f: config = json.load(f) client = CirtusAIClient(config[\"base_url\"]) if config.get(\"auto_login\"): token = client.auth.login_with_2fa( config[\"username\"], config[\"password\"], input(\"Enter TOTP code: \") ) client.set_token(token.access_token) return client API Reference AuthClient Methods Method Description Parameters Returns register() Register new user with 2FA username, email, password, preferred_2fa_method TwoFactorSetupResponse login() Initial login step username, password Token or TwoFactorRequiredResponse verify_2fa() Complete 2FA verification temporary_token, totp_code Token login_with_2fa() Complete 2FA login flow username, password, totp_code Token get_2fa_status() Get current 2FA status - TwoFactorStatusResponse setup_2fa() Setup 2FA for existing user - TwoFactorSetupResponse confirm_2fa() Confirm 2FA setup totp_code Dict disable_2fa() Disable 2FA totp_code, password Dict get_qr_code() Get QR code image - bytes request_sms_code() Request SMS code - Dict debug_2fa() Debug TOTP issues - Dict refresh() Refresh access token refresh_token Dict Response Models Token { \"access_token\": \"string\", \"token_type\": \"bearer\", \"expires_in\": 3600, \"refresh_token\": \"string\" } TwoFactorRequiredResponse { \"requires_2fa\": true, \"temporary_token\": \"string\", \"message\": \"2FA verification required\" } TwoFactorSetupResponse { \"secret_key\": \"string\", \"qr_code_url\": \"string\", \"backup_codes\": [\"code1\", \"code2\", ...], \"manual_entry_key\": \"string\" }","title":"Authentication"},{"location":"authentication/#cirtusai-sdk-authentication-guide","text":"","title":"CirtusAI SDK Authentication Guide"},{"location":"authentication/#overview","text":"The CirtusAI SDK provides comprehensive authentication capabilities with robust Two-Factor Authentication (2FA) support. The authentication system supports TOTP-based 2FA, SMS verification (framework ready), and complete user lifecycle management.","title":"Overview"},{"location":"authentication/#features","text":"User Registration : Automatic 2FA setup during registration Two-Step Login Flow : Secure authentication for 2FA-enabled users TOTP Management : Complete TOTP setup, verification, and management SMS 2FA Support : Framework ready for SMS-based authentication Debug Tools : Troubleshooting and time sync verification tools Token Management : Access token refresh and lifecycle management","title":"Features"},{"location":"authentication/#basic-authentication","text":"","title":"Basic Authentication"},{"location":"authentication/#user-registration","text":"Register a new user with automatic 2FA setup: from cirtusai import CirtusAIClient client = CirtusAIClient(\"https://api.cirtusai.com\") # Register with automatic 2FA setup setup_response = client.auth.register( username=\"your_username\", email=\"your_email@example.com\", password=\"your_secure_password\", preferred_2fa_method=\"totp\" # or \"sms\" ) print(f\"QR Code URL: {setup_response.qr_code_url}\") print(f\"Secret Key: {setup_response.secret_key}\") print(f\"Backup Codes: {setup_response.backup_codes}\")","title":"User Registration"},{"location":"authentication/#simple-login-no-2fa","text":"For accounts without 2FA enabled: # Direct login without 2FA token = client.auth.login(\"username\", \"password\") client.set_token(token.access_token)","title":"Simple Login (No 2FA)"},{"location":"authentication/#two-factor-authentication","text":"","title":"Two-Factor Authentication"},{"location":"authentication/#login-with-2fa","text":"","title":"Login with 2FA"},{"location":"authentication/#method-1-two-step-process","text":"# Step 1: Initial login login_result = client.auth.login(\"username\", \"password\") if hasattr(login_result, 'requires_2fa') and login_result.requires_2fa: # Step 2: Verify 2FA totp_code = input(\"Enter TOTP code: \") token = client.auth.verify_2fa(login_result.temporary_token, totp_code) client.set_token(token.access_token) else: # No 2FA required client.set_token(login_result.access_token)","title":"Method 1: Two-Step Process"},{"location":"authentication/#method-2-single-method","text":"# Complete 2FA login in one call try: token = client.auth.login_with_2fa(\"username\", \"password\", \"123456\") client.set_token(token.access_token) print(\"Login successful!\") except TwoFactorAuthenticationError as e: print(f\"2FA verification failed: {e}\")","title":"Method 2: Single Method"},{"location":"authentication/#2fa-management","text":"","title":"2FA Management"},{"location":"authentication/#check-2fa-status","text":"status = client.auth.get_2fa_status() print(f\"2FA Enabled: {status.enabled}\") print(f\"Method: {status.method}\") print(f\"Backup Codes Available: {status.backup_codes_remaining}\")","title":"Check 2FA Status"},{"location":"authentication/#setup-2fa-for-existing-user","text":"# Setup 2FA setup_response = client.auth.setup_2fa() print(f\"Scan this QR code: {setup_response.qr_code_url}\") # After scanning QR code, confirm with TOTP totp_code = input(\"Enter TOTP code from authenticator app: \") result = client.auth.confirm_2fa(totp_code) print(f\"2FA setup complete: {result}\")","title":"Setup 2FA for Existing User"},{"location":"authentication/#disable-2fa","text":"# Disable 2FA (requires current TOTP code and password) totp_code = input(\"Enter current TOTP code: \") password = input(\"Enter your password: \") result = client.auth.disable_2fa(totp_code, password) print(f\"2FA disabled: {result}\")","title":"Disable 2FA"},{"location":"authentication/#get-qr-code-image","text":"# Get QR code as PNG bytes qr_bytes = client.auth.get_qr_code() with open(\"qr_code.png\", \"wb\") as f: f.write(qr_bytes)","title":"Get QR Code Image"},{"location":"authentication/#sms-2fa-framework-ready","text":"# Request SMS code (when implemented) result = client.auth.request_sms_code() print(f\"SMS sent: {result}\")","title":"SMS 2FA (Framework Ready)"},{"location":"authentication/#debugging-and-troubleshooting","text":"","title":"Debugging and Troubleshooting"},{"location":"authentication/#debug-totp-issues","text":"# Debug TOTP setup and time sync debug_info = client.auth.debug_2fa() print(f\"Current valid codes: {debug_info.get('valid_codes')}\") print(f\"Server time: {debug_info.get('server_time')}\") print(f\"Time window: {debug_info.get('time_window')}\")","title":"Debug TOTP Issues"},{"location":"authentication/#token-management","text":"","title":"Token Management"},{"location":"authentication/#refresh-access-token","text":"# Refresh expired access token refresh_token = \"your_refresh_token\" new_tokens = client.auth.refresh(refresh_token) client.set_token(new_tokens[\"access_token\"])","title":"Refresh Access Token"},{"location":"authentication/#error-handling","text":"","title":"Error Handling"},{"location":"authentication/#custom-exception-handling","text":"from cirtusai.auth import TwoFactorAuthenticationError try: token = client.auth.login_with_2fa(\"username\", \"password\", \"invalid_code\") except TwoFactorAuthenticationError as e: print(f\"2FA Error: {e}\") except requests.exceptions.HTTPError as e: print(f\"HTTP Error: {e}\")","title":"Custom Exception Handling"},{"location":"authentication/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"authentication/#complete-registration-and-login-flow","text":"def complete_registration_flow(): client = CirtusAIClient(\"https://api.cirtusai.com\") # Register user setup = client.auth.register( username=\"new_user\", email=\"user@example.com\", password=\"secure_password\" ) print(\"Please scan this QR code with your authenticator app:\") print(setup.qr_code_url) # Wait for user to setup authenticator totp_code = input(\"Enter TOTP code to confirm setup: \") client.auth.confirm_2fa(totp_code) # Now login with 2FA token = client.auth.login_with_2fa(\"new_user\", \"secure_password\", totp_code) client.set_token(token.access_token) return client","title":"Complete Registration and Login Flow"},{"location":"authentication/#session-management","text":"class AuthenticatedSession: def __init__(self, base_url, username, password): self.client = CirtusAIClient(base_url) self.username = username self.password = password self._authenticate() def _authenticate(self): login_result = self.client.auth.login(self.username, self.password) if hasattr(login_result, 'requires_2fa'): totp_code = input(\"Enter TOTP code: \") token = self.client.auth.verify_2fa( login_result.temporary_token, totp_code ) else: token = login_result self.client.set_token(token.access_token) def get_client(self): return self.client","title":"Session Management"},{"location":"authentication/#security-best-practices","text":"","title":"Security Best Practices"},{"location":"authentication/#1-secure-token-storage","text":"import keyring # Store tokens securely def store_token_securely(token): keyring.set_password(\"cirtusai\", \"access_token\", token) def get_stored_token(): return keyring.get_password(\"cirtusai\", \"access_token\")","title":"1. Secure Token Storage"},{"location":"authentication/#2-automatic-token-refresh","text":"def auto_refresh_client(client, refresh_token): try: # Attempt API call response = client.some_api_call() return response except requests.exceptions.HTTPError as e: if e.response.status_code == 401: # Token expired, refresh new_tokens = client.auth.refresh(refresh_token) client.set_token(new_tokens[\"access_token\"]) # Retry original call return client.some_api_call() raise","title":"2. Automatic Token Refresh"},{"location":"authentication/#3-backup-code-management","text":"def save_backup_codes(backup_codes): \"\"\"Save backup codes securely\"\"\" with open(\"backup_codes.txt\", \"w\") as f: f.write(\"CirtusAI Backup Codes (Store Securely):\\n\") for i, code in enumerate(backup_codes, 1): f.write(f\"{i}. {code}\\n\") print(\"Backup codes saved to backup_codes.txt - store this file securely!\")","title":"3. Backup Code Management"},{"location":"authentication/#configuration","text":"","title":"Configuration"},{"location":"authentication/#environment-variables","text":"import os from cirtusai import CirtusAIClient # Configure using environment variables client = CirtusAIClient( base_url=os.getenv(\"CIRTUSAI_API_URL\", \"https://api.cirtusai.com\"), token=os.getenv(\"CIRTUSAI_ACCESS_TOKEN\") )","title":"Environment Variables"},{"location":"authentication/#configuration-file","text":"import json def load_auth_config(config_file=\"cirtusai_config.json\"): with open(config_file) as f: config = json.load(f) client = CirtusAIClient(config[\"base_url\"]) if config.get(\"auto_login\"): token = client.auth.login_with_2fa( config[\"username\"], config[\"password\"], input(\"Enter TOTP code: \") ) client.set_token(token.access_token) return client","title":"Configuration File"},{"location":"authentication/#api-reference","text":"","title":"API Reference"},{"location":"authentication/#authclient-methods","text":"Method Description Parameters Returns register() Register new user with 2FA username, email, password, preferred_2fa_method TwoFactorSetupResponse login() Initial login step username, password Token or TwoFactorRequiredResponse verify_2fa() Complete 2FA verification temporary_token, totp_code Token login_with_2fa() Complete 2FA login flow username, password, totp_code Token get_2fa_status() Get current 2FA status - TwoFactorStatusResponse setup_2fa() Setup 2FA for existing user - TwoFactorSetupResponse confirm_2fa() Confirm 2FA setup totp_code Dict disable_2fa() Disable 2FA totp_code, password Dict get_qr_code() Get QR code image - bytes request_sms_code() Request SMS code - Dict debug_2fa() Debug TOTP issues - Dict refresh() Refresh access token refresh_token Dict","title":"AuthClient Methods"},{"location":"authentication/#response-models","text":"","title":"Response Models"},{"location":"authentication/#token","text":"{ \"access_token\": \"string\", \"token_type\": \"bearer\", \"expires_in\": 3600, \"refresh_token\": \"string\" }","title":"Token"},{"location":"authentication/#twofactorrequiredresponse","text":"{ \"requires_2fa\": true, \"temporary_token\": \"string\", \"message\": \"2FA verification required\" }","title":"TwoFactorRequiredResponse"},{"location":"authentication/#twofactorsetupresponse","text":"{ \"secret_key\": \"string\", \"qr_code_url\": \"string\", \"backup_codes\": [\"code1\", \"code2\", ...], \"manual_entry_key\": \"string\" }","title":"TwoFactorSetupResponse"},{"location":"blockchain/","text":"CirtusAI SDK Blockchain Infrastructure Guide Overview The CirtusAI SDK provides comprehensive blockchain infrastructure components including cross-chain bridging, DeFi swaps, NFT management, governance operations, identity management, and marketplace functionality. These modules enable seamless interaction with multiple blockchain networks. Cross-Chain Bridge Bridge Operations from cirtusai import CirtusAIClient client = CirtusAIClient(\"https://api.cirtusai.com\") client.set_token(\"your_access_token\") # Get bridge quote for cross-chain transfer quote = client.bridge.get_quote( from_chain=\"ethereum\", to_chain=\"polygon\", from_token=\"ETH\", to_token=\"MATIC\", amount=1000000000000000000 # 1 ETH in wei ) print(f\"Estimated output: {quote['estimated_output']}\") print(f\"Fee: {quote['fee']}\") print(f\"Estimated time: {quote['estimated_time']}\") # Execute bridge transfer bridge_result = client.bridge.bridge_transfer( provider=\"multichain\", from_chain=\"ethereum\", to_chain=\"polygon\", from_token=\"ETH\", to_token=\"MATIC\", amount=1000000000000000000, recipient_address=\"0x742d35Cc6635C0532925a3b8D\" ) print(f\"Bridge transaction: {bridge_result['transaction_hash']}\") print(f\"Bridge ID: {bridge_result['bridge_id']}\") Multi-Chain Asset View # Get consolidated view of assets across chains asset_view = client.bridge.get_multi_chain_asset_view() print(\"Multi-chain asset portfolio:\") for chain, assets in asset_view.items(): print(f\"\\n{chain.upper()}:\") for asset in assets: print(f\" {asset['symbol']}: {asset['balance']} ({asset['usd_value']} USD)\") # Refresh the asset view refreshed_view = client.bridge.refresh_multi_chain_asset_view() print(f\"Asset view refreshed: {refreshed_view['updated_at']}\") DeFi Swap Operations Token Swaps # Get swap quote swap_quote = client.swap.get_quote( from_chain=\"ethereum\", to_chain=\"ethereum\", from_token=\"USDC\", to_token=\"ETH\", amount=1000.0 # 1000 USDC ) print(f\"Estimated ETH output: {swap_quote['estimated_output']}\") print(f\"Price impact: {swap_quote['price_impact']}%\") print(f\"Slippage tolerance: {swap_quote['slippage_tolerance']}%\") # Execute swap swap_data = { \"from_token\": \"USDC\", \"to_token\": \"ETH\", \"amount\": 1000.0, \"slippage_tolerance\": 0.5, \"deadline\": 1800 # 30 minutes } swap_result = client.swap.execute_swap(swap_data) print(f\"Swap transaction: {swap_result['transaction_hash']}\") print(f\"Swap ID: {swap_result['swap_id']}\") # Cancel pending swap if needed client.swap.cancel_swap(\"swap_123\") NFT Management NFT Operations # List NFTs in wallet nfts = client.nfts.list_nfts(wallet_id=\"wallet_123\") for nft in nfts: print(f\"Contract: {nft['contract_address']}\") print(f\"Token ID: {nft['token_id']}\") print(f\"Name: {nft['name']}\") print(f\"Description: {nft['description']}\") # Get specific NFT metadata metadata = client.nfts.get_nft_metadata( contract_address=\"0x1234567890123456789012345678901234567890\", token_id=\"1\" ) print(f\"NFT metadata: {metadata}\") # Mint new NFT mint_result = client.nfts.mint_nft( contract_address=\"0x1234567890123456789012345678901234567890\", to_address=\"0x742d35Cc6635C0532925a3b8D\", metadata_uri=\"https://metadata.example.com/nft/1\" ) print(f\"Mint transaction: {mint_result['transaction_hash']}\") # Batch transfer NFTs transfers = [ { \"token_id\": \"1\", \"to_address\": \"0x742d35Cc6635C0532925a3b8D\" }, { \"token_id\": \"2\", \"to_address\": \"0x1234567890123456789012345678901234567890\" } ] batch_result = client.nfts.batch_transfer( contract_address=\"0x1234567890123456789012345678901234567890\", transfers=transfers ) # Burn NFT client.nfts.burn_nft( contract_address=\"0x1234567890123456789012345678901234567890\", token_id=\"3\" ) Governance DAO Governance Operations # Create governance proposal proposal = client.governance.create_proposal( targets=[\"0x1234567890123456789012345678901234567890\"], values=[0], calldatas=[\"0xa9059cbb000000000000000000000000742d35cc6635c0532925a3b8d00000000000000000000000000000000000000000000000000000000000000064\"], description=\"Transfer 100 tokens to community fund\" ) print(f\"Proposal ID: {proposal['proposal_id']}\") print(f\"Proposal state: {proposal['state']}\") # Cast vote on proposal vote_result = client.governance.cast_vote( proposal_id=1, support=1 # 0=against, 1=for, 2=abstain ) print(f\"Vote transaction: {vote_result['transaction_hash']}\") # Get proposal state proposal_state = client.governance.get_proposal_state(proposal_id=1) print(f\"Current state: {proposal_state['state']}\") print(f\"For votes: {proposal_state['for_votes']}\") print(f\"Against votes: {proposal_state['against_votes']}\") Identity & Reputation Decentralized Identity (DID) # Get DID for agent did_info = client.identity.get_did(agent_id=\"agent_123\") print(f\"DID: {did_info['did']}\") print(f\"Public key: {did_info['public_key']}\") # Issue verifiable credential credential = client.identity.issue_credential( subject_id=\"user_123\", types=[\"VerifiableCredential\", \"KYCCredential\"], claim={ \"kyc_verified\": True, \"verification_level\": \"enhanced\", \"verified_at\": \"2024-01-15T10:30:00Z\" } ) print(f\"Credential issued: {credential['credential_id']}\") # Verify credential verification = client.identity.verify_credential( jwt_token=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...\" ) print(f\"Verification status: {verification['valid']}\") print(f\"Claims: {verification['claims']}\") Soulbound Tokens (SBT) # Issue soulbound token for reputation sbt_result = client.reputation.issue_sbt( to_address=\"0x742d35Cc6635C0532925a3b8D\", token_uri=\"https://metadata.example.com/sbt/reputation/1\" ) print(f\"SBT transaction: {sbt_result['transaction_hash']}\") # Get SBT owner owner = client.reputation.get_sbt_owner(token_id=1) print(f\"SBT owner: {owner}\") Marketplace NFT Marketplace Operations # Create marketplace listing listing_data = { \"nft_contract\": \"0x1234567890123456789012345678901234567890\", \"token_id\": \"1\", \"price\": \"1.5\", # ETH \"currency\": \"ETH\", \"duration\": 7 # days } listing = client.marketplace.create_listing(listing_data) print(f\"Listing ID: {listing['listing_id']}\") print(f\"Status: {listing['status']}\") # Get specific listing listing_info = client.marketplace.get_listing(\"listing_123\") print(f\"Price: {listing_info['price']} {listing_info['currency']}\") print(f\"Seller: {listing_info['seller']}\") # List all available listings listings = client.marketplace.list_listings( filters={ \"min_price\": 0.1, \"max_price\": 10.0, \"currency\": \"ETH\" } ) for listing in listings: print(f\"Listing {listing['listing_id']}: {listing['price']} {listing['currency']}\") # Place bid on listing bid_data = { \"price\": \"1.2\", \"currency\": \"ETH\", \"expires_at\": \"2024-01-20T10:30:00Z\" } bid = client.marketplace.place_bid( listing_id=\"listing_123\", bid_data=bid_data ) print(f\"Bid placed: {bid['bid_id']}\") # List bids for a listing bids = client.marketplace.list_bids(\"listing_123\") for bid in bids: print(f\"Bid {bid['bid_id']}: {bid['price']} {bid['currency']} by {bid['bidder']}\") # Accept bid (as seller) accept_result = client.marketplace.accept_bid( listing_id=\"listing_123\", bid_id=\"bid_456\" ) print(f\"Bid accepted: {accept_result['transaction_hash']}\") # Update listing updated_listing = client.marketplace.update_listing( listing_id=\"listing_123\", listing_data={\"price\": \"1.3\"} ) # Cancel listing client.marketplace.cancel_listing(\"listing_123\") Child Assets Management Child Agent Asset Operations # List assets for child agent child_assets = client.child_assets.list_child_assets(child_id=\"child_123\") for asset in child_assets: print(f\"Asset ID: {asset['asset_id']}\") print(f\"Type: {asset['asset_type']}\") print(f\"Value: {asset['asset_value']}\") # Get specific child asset asset = client.child_assets.get_child_asset(\"asset_123\") print(f\"Asset details: {asset}\") # Create new asset for child asset_data = { \"asset_type\": \"email_account\", \"asset_value\": \"child_agent@example.com\", \"metadata\": { \"provider\": \"gmail\", \"configured\": True } } new_asset = client.child_assets.create_child_asset( child_id=\"child_123\", asset_data=asset_data ) print(f\"Created asset: {new_asset['asset_id']}\") # Update child asset updated_asset = client.child_assets.update_child_asset( asset_id=\"asset_123\", asset_data={\"metadata\": {\"status\": \"active\"}} ) # Delete child asset client.child_assets.delete_child_asset(\"asset_123\") Advanced Blockchain Workflows Cross-Chain DeFi Strategy def execute_cross_chain_strategy(client, strategy_config): \"\"\"Execute complex cross-chain DeFi strategy\"\"\" results = [] for step in strategy_config[\"steps\"]: if step[\"type\"] == \"bridge\": # Bridge assets to target chain quote = client.bridge.get_quote( from_chain=step[\"from_chain\"], to_chain=step[\"to_chain\"], from_token=step[\"from_token\"], to_token=step[\"to_token\"], amount=step[\"amount\"] ) if quote[\"estimated_output\"] >= step[\"min_output\"]: bridge_result = client.bridge.bridge_transfer( provider=step[\"provider\"], from_chain=step[\"from_chain\"], to_chain=step[\"to_chain\"], from_token=step[\"from_token\"], to_token=step[\"to_token\"], amount=step[\"amount\"], recipient_address=step[\"recipient\"] ) results.append({\"step\": \"bridge\", \"result\": bridge_result}) elif step[\"type\"] == \"swap\": # Execute DeFi swap swap_result = client.swap.execute_swap(step[\"swap_data\"]) results.append({\"step\": \"swap\", \"result\": swap_result}) return results # Strategy configuration strategy = { \"steps\": [ { \"type\": \"bridge\", \"from_chain\": \"ethereum\", \"to_chain\": \"polygon\", \"from_token\": \"USDC\", \"to_token\": \"USDC\", \"amount\": 1000, \"min_output\": 995, \"provider\": \"multichain\", \"recipient\": \"0x742d35Cc6635C0532925a3b8D\" }, { \"type\": \"swap\", \"swap_data\": { \"from_token\": \"USDC\", \"to_token\": \"MATIC\", \"amount\": 1000, \"slippage_tolerance\": 0.5 } } ] } results = execute_cross_chain_strategy(client, strategy) print(f\"Strategy executed with {len(results)} steps\") NFT Collection Management def manage_nft_collection(client, collection_config): \"\"\"Comprehensive NFT collection management\"\"\" collection_stats = { \"total_nfts\": 0, \"minted\": 0, \"transferred\": 0, \"listed\": 0 } # Mint NFTs in batch for i in range(collection_config[\"mint_count\"]): try: mint_result = client.nfts.mint_nft( contract_address=collection_config[\"contract\"], to_address=collection_config[\"owner\"], metadata_uri=f\"{collection_config['base_uri']}/{i}\" ) collection_stats[\"minted\"] += 1 print(f\"Minted NFT #{i}: {mint_result['transaction_hash']}\") except Exception as e: print(f\"Failed to mint NFT #{i}: {e}\") # List NFTs on marketplace nfts = client.nfts.list_nfts(collection_config[\"wallet_id\"]) for nft in nfts[:collection_config.get(\"list_count\", 5)]: try: listing_data = { \"nft_contract\": nft[\"contract_address\"], \"token_id\": nft[\"token_id\"], \"price\": collection_config[\"list_price\"], \"currency\": \"ETH\", \"duration\": 30 } listing = client.marketplace.create_listing(listing_data) collection_stats[\"listed\"] += 1 print(f\"Listed NFT {nft['token_id']}: {listing['listing_id']}\") except Exception as e: print(f\"Failed to list NFT {nft['token_id']}: {e}\") return collection_stats # Collection configuration config = { \"contract\": \"0x1234567890123456789012345678901234567890\", \"owner\": \"0x742d35Cc6635C0532925a3b8D\", \"wallet_id\": \"wallet_123\", \"base_uri\": \"https://metadata.example.com/collection\", \"mint_count\": 10, \"list_count\": 5, \"list_price\": \"0.1\" } stats = manage_nft_collection(client, config) print(f\"Collection stats: {stats}\") DAO Governance Automation def automated_governance_participation(client, governance_config): \"\"\"Automate DAO governance participation\"\"\" # Get current proposal state proposal_id = governance_config[\"proposal_id\"] proposal_state = client.governance.get_proposal_state(proposal_id) print(f\"Proposal {proposal_id} state: {proposal_state['state']}\") # Voting logic based on configuration if proposal_state[\"state\"] == \"Active\": voting_decision = governance_config.get(\"auto_vote\") if voting_decision is not None: vote_result = client.governance.cast_vote( proposal_id=proposal_id, support=voting_decision ) print(f\"Automatic vote cast: {vote_result['transaction_hash']}\") else: print(\"Manual voting required - no auto-vote configured\") # Create new proposal if configured if governance_config.get(\"create_proposal\"): proposal_data = governance_config[\"proposal_data\"] new_proposal = client.governance.create_proposal( targets=proposal_data[\"targets\"], values=proposal_data[\"values\"], calldatas=proposal_data[\"calldatas\"], description=proposal_data[\"description\"] ) print(f\"New proposal created: {new_proposal['proposal_id']}\") return { \"current_proposal_state\": proposal_state, \"actions_taken\": [\"vote_cast\"] if voting_decision is not None else [] } # Governance configuration gov_config = { \"proposal_id\": 1, \"auto_vote\": 1, # 1 = for, 0 = against, 2 = abstain \"create_proposal\": False, \"proposal_data\": { \"targets\": [\"0x1234567890123456789012345678901234567890\"], \"values\": [0], \"calldatas\": [\"0x\"], \"description\": \"Community treasury allocation\" } } governance_result = automated_governance_participation(client, gov_config) Error Handling Blockchain Operation Safety def safe_blockchain_operation(client, module, operation, *args, **kwargs): \"\"\"Safely execute blockchain operations with proper error handling\"\"\" try: module_client = getattr(client, module) result = getattr(module_client, operation)(*args, **kwargs) return {\"success\": True, \"result\": result} except requests.exceptions.HTTPError as e: error_code = e.response.status_code if error_code == 400: return {\"success\": False, \"error\": \"Invalid parameters\"} elif error_code == 403: return {\"success\": False, \"error\": \"Insufficient permissions\"} elif error_code == 429: return {\"success\": False, \"error\": \"Rate limit exceeded\"} else: return {\"success\": False, \"error\": f\"HTTP {error_code}: {e}\"} except Exception as e: return {\"success\": False, \"error\": f\"Unexpected error: {str(e)}\"} # Usage examples bridge_result = safe_blockchain_operation( client, \"bridge\", \"get_quote\", \"ethereum\", \"polygon\", \"ETH\", \"MATIC\", 1000000000000000000 ) if bridge_result[\"success\"]: print(f\"Bridge quote: {bridge_result['result']}\") else: print(f\"Bridge operation failed: {bridge_result['error']}\") API Reference Summary Available Modules Module Description Key Methods bridge Cross-chain bridging get_quote() , bridge_transfer() , get_multi_chain_asset_view() swap DeFi token swaps get_quote() , execute_swap() , cancel_swap() nfts NFT management list_nfts() , mint_nft() , batch_transfer() , burn_nft() governance DAO governance create_proposal() , cast_vote() , get_proposal_state() identity Decentralized identity get_did() , issue_credential() , verify_credential() reputation Soulbound tokens issue_sbt() , get_sbt_owner() marketplace NFT marketplace create_listing() , place_bid() , accept_bid() child_assets Child agent assets list_child_assets() , create_child_asset() Common Response Patterns All blockchain operations return transaction hashes and operation IDs for tracking: { \"transaction_hash\": \"0x1234567890abcdef...\", \"operation_id\": \"op_123\", \"status\": \"pending\" | \"confirmed\" | \"failed\", \"block_number\": 12345678, \"gas_used\": 21000 }","title":"Blockchain Infrastructure"},{"location":"blockchain/#cirtusai-sdk-blockchain-infrastructure-guide","text":"","title":"CirtusAI SDK Blockchain Infrastructure Guide"},{"location":"blockchain/#overview","text":"The CirtusAI SDK provides comprehensive blockchain infrastructure components including cross-chain bridging, DeFi swaps, NFT management, governance operations, identity management, and marketplace functionality. These modules enable seamless interaction with multiple blockchain networks.","title":"Overview"},{"location":"blockchain/#cross-chain-bridge","text":"","title":"Cross-Chain Bridge"},{"location":"blockchain/#bridge-operations","text":"from cirtusai import CirtusAIClient client = CirtusAIClient(\"https://api.cirtusai.com\") client.set_token(\"your_access_token\") # Get bridge quote for cross-chain transfer quote = client.bridge.get_quote( from_chain=\"ethereum\", to_chain=\"polygon\", from_token=\"ETH\", to_token=\"MATIC\", amount=1000000000000000000 # 1 ETH in wei ) print(f\"Estimated output: {quote['estimated_output']}\") print(f\"Fee: {quote['fee']}\") print(f\"Estimated time: {quote['estimated_time']}\") # Execute bridge transfer bridge_result = client.bridge.bridge_transfer( provider=\"multichain\", from_chain=\"ethereum\", to_chain=\"polygon\", from_token=\"ETH\", to_token=\"MATIC\", amount=1000000000000000000, recipient_address=\"0x742d35Cc6635C0532925a3b8D\" ) print(f\"Bridge transaction: {bridge_result['transaction_hash']}\") print(f\"Bridge ID: {bridge_result['bridge_id']}\")","title":"Bridge Operations"},{"location":"blockchain/#multi-chain-asset-view","text":"# Get consolidated view of assets across chains asset_view = client.bridge.get_multi_chain_asset_view() print(\"Multi-chain asset portfolio:\") for chain, assets in asset_view.items(): print(f\"\\n{chain.upper()}:\") for asset in assets: print(f\" {asset['symbol']}: {asset['balance']} ({asset['usd_value']} USD)\") # Refresh the asset view refreshed_view = client.bridge.refresh_multi_chain_asset_view() print(f\"Asset view refreshed: {refreshed_view['updated_at']}\")","title":"Multi-Chain Asset View"},{"location":"blockchain/#defi-swap-operations","text":"","title":"DeFi Swap Operations"},{"location":"blockchain/#token-swaps","text":"# Get swap quote swap_quote = client.swap.get_quote( from_chain=\"ethereum\", to_chain=\"ethereum\", from_token=\"USDC\", to_token=\"ETH\", amount=1000.0 # 1000 USDC ) print(f\"Estimated ETH output: {swap_quote['estimated_output']}\") print(f\"Price impact: {swap_quote['price_impact']}%\") print(f\"Slippage tolerance: {swap_quote['slippage_tolerance']}%\") # Execute swap swap_data = { \"from_token\": \"USDC\", \"to_token\": \"ETH\", \"amount\": 1000.0, \"slippage_tolerance\": 0.5, \"deadline\": 1800 # 30 minutes } swap_result = client.swap.execute_swap(swap_data) print(f\"Swap transaction: {swap_result['transaction_hash']}\") print(f\"Swap ID: {swap_result['swap_id']}\") # Cancel pending swap if needed client.swap.cancel_swap(\"swap_123\")","title":"Token Swaps"},{"location":"blockchain/#nft-management","text":"","title":"NFT Management"},{"location":"blockchain/#nft-operations","text":"# List NFTs in wallet nfts = client.nfts.list_nfts(wallet_id=\"wallet_123\") for nft in nfts: print(f\"Contract: {nft['contract_address']}\") print(f\"Token ID: {nft['token_id']}\") print(f\"Name: {nft['name']}\") print(f\"Description: {nft['description']}\") # Get specific NFT metadata metadata = client.nfts.get_nft_metadata( contract_address=\"0x1234567890123456789012345678901234567890\", token_id=\"1\" ) print(f\"NFT metadata: {metadata}\") # Mint new NFT mint_result = client.nfts.mint_nft( contract_address=\"0x1234567890123456789012345678901234567890\", to_address=\"0x742d35Cc6635C0532925a3b8D\", metadata_uri=\"https://metadata.example.com/nft/1\" ) print(f\"Mint transaction: {mint_result['transaction_hash']}\") # Batch transfer NFTs transfers = [ { \"token_id\": \"1\", \"to_address\": \"0x742d35Cc6635C0532925a3b8D\" }, { \"token_id\": \"2\", \"to_address\": \"0x1234567890123456789012345678901234567890\" } ] batch_result = client.nfts.batch_transfer( contract_address=\"0x1234567890123456789012345678901234567890\", transfers=transfers ) # Burn NFT client.nfts.burn_nft( contract_address=\"0x1234567890123456789012345678901234567890\", token_id=\"3\" )","title":"NFT Operations"},{"location":"blockchain/#governance","text":"","title":"Governance"},{"location":"blockchain/#dao-governance-operations","text":"# Create governance proposal proposal = client.governance.create_proposal( targets=[\"0x1234567890123456789012345678901234567890\"], values=[0], calldatas=[\"0xa9059cbb000000000000000000000000742d35cc6635c0532925a3b8d00000000000000000000000000000000000000000000000000000000000000064\"], description=\"Transfer 100 tokens to community fund\" ) print(f\"Proposal ID: {proposal['proposal_id']}\") print(f\"Proposal state: {proposal['state']}\") # Cast vote on proposal vote_result = client.governance.cast_vote( proposal_id=1, support=1 # 0=against, 1=for, 2=abstain ) print(f\"Vote transaction: {vote_result['transaction_hash']}\") # Get proposal state proposal_state = client.governance.get_proposal_state(proposal_id=1) print(f\"Current state: {proposal_state['state']}\") print(f\"For votes: {proposal_state['for_votes']}\") print(f\"Against votes: {proposal_state['against_votes']}\")","title":"DAO Governance Operations"},{"location":"blockchain/#identity-reputation","text":"","title":"Identity &amp; Reputation"},{"location":"blockchain/#decentralized-identity-did","text":"# Get DID for agent did_info = client.identity.get_did(agent_id=\"agent_123\") print(f\"DID: {did_info['did']}\") print(f\"Public key: {did_info['public_key']}\") # Issue verifiable credential credential = client.identity.issue_credential( subject_id=\"user_123\", types=[\"VerifiableCredential\", \"KYCCredential\"], claim={ \"kyc_verified\": True, \"verification_level\": \"enhanced\", \"verified_at\": \"2024-01-15T10:30:00Z\" } ) print(f\"Credential issued: {credential['credential_id']}\") # Verify credential verification = client.identity.verify_credential( jwt_token=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...\" ) print(f\"Verification status: {verification['valid']}\") print(f\"Claims: {verification['claims']}\")","title":"Decentralized Identity (DID)"},{"location":"blockchain/#soulbound-tokens-sbt","text":"# Issue soulbound token for reputation sbt_result = client.reputation.issue_sbt( to_address=\"0x742d35Cc6635C0532925a3b8D\", token_uri=\"https://metadata.example.com/sbt/reputation/1\" ) print(f\"SBT transaction: {sbt_result['transaction_hash']}\") # Get SBT owner owner = client.reputation.get_sbt_owner(token_id=1) print(f\"SBT owner: {owner}\")","title":"Soulbound Tokens (SBT)"},{"location":"blockchain/#marketplace","text":"","title":"Marketplace"},{"location":"blockchain/#nft-marketplace-operations","text":"# Create marketplace listing listing_data = { \"nft_contract\": \"0x1234567890123456789012345678901234567890\", \"token_id\": \"1\", \"price\": \"1.5\", # ETH \"currency\": \"ETH\", \"duration\": 7 # days } listing = client.marketplace.create_listing(listing_data) print(f\"Listing ID: {listing['listing_id']}\") print(f\"Status: {listing['status']}\") # Get specific listing listing_info = client.marketplace.get_listing(\"listing_123\") print(f\"Price: {listing_info['price']} {listing_info['currency']}\") print(f\"Seller: {listing_info['seller']}\") # List all available listings listings = client.marketplace.list_listings( filters={ \"min_price\": 0.1, \"max_price\": 10.0, \"currency\": \"ETH\" } ) for listing in listings: print(f\"Listing {listing['listing_id']}: {listing['price']} {listing['currency']}\") # Place bid on listing bid_data = { \"price\": \"1.2\", \"currency\": \"ETH\", \"expires_at\": \"2024-01-20T10:30:00Z\" } bid = client.marketplace.place_bid( listing_id=\"listing_123\", bid_data=bid_data ) print(f\"Bid placed: {bid['bid_id']}\") # List bids for a listing bids = client.marketplace.list_bids(\"listing_123\") for bid in bids: print(f\"Bid {bid['bid_id']}: {bid['price']} {bid['currency']} by {bid['bidder']}\") # Accept bid (as seller) accept_result = client.marketplace.accept_bid( listing_id=\"listing_123\", bid_id=\"bid_456\" ) print(f\"Bid accepted: {accept_result['transaction_hash']}\") # Update listing updated_listing = client.marketplace.update_listing( listing_id=\"listing_123\", listing_data={\"price\": \"1.3\"} ) # Cancel listing client.marketplace.cancel_listing(\"listing_123\")","title":"NFT Marketplace Operations"},{"location":"blockchain/#child-assets-management","text":"","title":"Child Assets Management"},{"location":"blockchain/#child-agent-asset-operations","text":"# List assets for child agent child_assets = client.child_assets.list_child_assets(child_id=\"child_123\") for asset in child_assets: print(f\"Asset ID: {asset['asset_id']}\") print(f\"Type: {asset['asset_type']}\") print(f\"Value: {asset['asset_value']}\") # Get specific child asset asset = client.child_assets.get_child_asset(\"asset_123\") print(f\"Asset details: {asset}\") # Create new asset for child asset_data = { \"asset_type\": \"email_account\", \"asset_value\": \"child_agent@example.com\", \"metadata\": { \"provider\": \"gmail\", \"configured\": True } } new_asset = client.child_assets.create_child_asset( child_id=\"child_123\", asset_data=asset_data ) print(f\"Created asset: {new_asset['asset_id']}\") # Update child asset updated_asset = client.child_assets.update_child_asset( asset_id=\"asset_123\", asset_data={\"metadata\": {\"status\": \"active\"}} ) # Delete child asset client.child_assets.delete_child_asset(\"asset_123\")","title":"Child Agent Asset Operations"},{"location":"blockchain/#advanced-blockchain-workflows","text":"","title":"Advanced Blockchain Workflows"},{"location":"blockchain/#cross-chain-defi-strategy","text":"def execute_cross_chain_strategy(client, strategy_config): \"\"\"Execute complex cross-chain DeFi strategy\"\"\" results = [] for step in strategy_config[\"steps\"]: if step[\"type\"] == \"bridge\": # Bridge assets to target chain quote = client.bridge.get_quote( from_chain=step[\"from_chain\"], to_chain=step[\"to_chain\"], from_token=step[\"from_token\"], to_token=step[\"to_token\"], amount=step[\"amount\"] ) if quote[\"estimated_output\"] >= step[\"min_output\"]: bridge_result = client.bridge.bridge_transfer( provider=step[\"provider\"], from_chain=step[\"from_chain\"], to_chain=step[\"to_chain\"], from_token=step[\"from_token\"], to_token=step[\"to_token\"], amount=step[\"amount\"], recipient_address=step[\"recipient\"] ) results.append({\"step\": \"bridge\", \"result\": bridge_result}) elif step[\"type\"] == \"swap\": # Execute DeFi swap swap_result = client.swap.execute_swap(step[\"swap_data\"]) results.append({\"step\": \"swap\", \"result\": swap_result}) return results # Strategy configuration strategy = { \"steps\": [ { \"type\": \"bridge\", \"from_chain\": \"ethereum\", \"to_chain\": \"polygon\", \"from_token\": \"USDC\", \"to_token\": \"USDC\", \"amount\": 1000, \"min_output\": 995, \"provider\": \"multichain\", \"recipient\": \"0x742d35Cc6635C0532925a3b8D\" }, { \"type\": \"swap\", \"swap_data\": { \"from_token\": \"USDC\", \"to_token\": \"MATIC\", \"amount\": 1000, \"slippage_tolerance\": 0.5 } } ] } results = execute_cross_chain_strategy(client, strategy) print(f\"Strategy executed with {len(results)} steps\")","title":"Cross-Chain DeFi Strategy"},{"location":"blockchain/#nft-collection-management","text":"def manage_nft_collection(client, collection_config): \"\"\"Comprehensive NFT collection management\"\"\" collection_stats = { \"total_nfts\": 0, \"minted\": 0, \"transferred\": 0, \"listed\": 0 } # Mint NFTs in batch for i in range(collection_config[\"mint_count\"]): try: mint_result = client.nfts.mint_nft( contract_address=collection_config[\"contract\"], to_address=collection_config[\"owner\"], metadata_uri=f\"{collection_config['base_uri']}/{i}\" ) collection_stats[\"minted\"] += 1 print(f\"Minted NFT #{i}: {mint_result['transaction_hash']}\") except Exception as e: print(f\"Failed to mint NFT #{i}: {e}\") # List NFTs on marketplace nfts = client.nfts.list_nfts(collection_config[\"wallet_id\"]) for nft in nfts[:collection_config.get(\"list_count\", 5)]: try: listing_data = { \"nft_contract\": nft[\"contract_address\"], \"token_id\": nft[\"token_id\"], \"price\": collection_config[\"list_price\"], \"currency\": \"ETH\", \"duration\": 30 } listing = client.marketplace.create_listing(listing_data) collection_stats[\"listed\"] += 1 print(f\"Listed NFT {nft['token_id']}: {listing['listing_id']}\") except Exception as e: print(f\"Failed to list NFT {nft['token_id']}: {e}\") return collection_stats # Collection configuration config = { \"contract\": \"0x1234567890123456789012345678901234567890\", \"owner\": \"0x742d35Cc6635C0532925a3b8D\", \"wallet_id\": \"wallet_123\", \"base_uri\": \"https://metadata.example.com/collection\", \"mint_count\": 10, \"list_count\": 5, \"list_price\": \"0.1\" } stats = manage_nft_collection(client, config) print(f\"Collection stats: {stats}\")","title":"NFT Collection Management"},{"location":"blockchain/#dao-governance-automation","text":"def automated_governance_participation(client, governance_config): \"\"\"Automate DAO governance participation\"\"\" # Get current proposal state proposal_id = governance_config[\"proposal_id\"] proposal_state = client.governance.get_proposal_state(proposal_id) print(f\"Proposal {proposal_id} state: {proposal_state['state']}\") # Voting logic based on configuration if proposal_state[\"state\"] == \"Active\": voting_decision = governance_config.get(\"auto_vote\") if voting_decision is not None: vote_result = client.governance.cast_vote( proposal_id=proposal_id, support=voting_decision ) print(f\"Automatic vote cast: {vote_result['transaction_hash']}\") else: print(\"Manual voting required - no auto-vote configured\") # Create new proposal if configured if governance_config.get(\"create_proposal\"): proposal_data = governance_config[\"proposal_data\"] new_proposal = client.governance.create_proposal( targets=proposal_data[\"targets\"], values=proposal_data[\"values\"], calldatas=proposal_data[\"calldatas\"], description=proposal_data[\"description\"] ) print(f\"New proposal created: {new_proposal['proposal_id']}\") return { \"current_proposal_state\": proposal_state, \"actions_taken\": [\"vote_cast\"] if voting_decision is not None else [] } # Governance configuration gov_config = { \"proposal_id\": 1, \"auto_vote\": 1, # 1 = for, 0 = against, 2 = abstain \"create_proposal\": False, \"proposal_data\": { \"targets\": [\"0x1234567890123456789012345678901234567890\"], \"values\": [0], \"calldatas\": [\"0x\"], \"description\": \"Community treasury allocation\" } } governance_result = automated_governance_participation(client, gov_config)","title":"DAO Governance Automation"},{"location":"blockchain/#error-handling","text":"","title":"Error Handling"},{"location":"blockchain/#blockchain-operation-safety","text":"def safe_blockchain_operation(client, module, operation, *args, **kwargs): \"\"\"Safely execute blockchain operations with proper error handling\"\"\" try: module_client = getattr(client, module) result = getattr(module_client, operation)(*args, **kwargs) return {\"success\": True, \"result\": result} except requests.exceptions.HTTPError as e: error_code = e.response.status_code if error_code == 400: return {\"success\": False, \"error\": \"Invalid parameters\"} elif error_code == 403: return {\"success\": False, \"error\": \"Insufficient permissions\"} elif error_code == 429: return {\"success\": False, \"error\": \"Rate limit exceeded\"} else: return {\"success\": False, \"error\": f\"HTTP {error_code}: {e}\"} except Exception as e: return {\"success\": False, \"error\": f\"Unexpected error: {str(e)}\"} # Usage examples bridge_result = safe_blockchain_operation( client, \"bridge\", \"get_quote\", \"ethereum\", \"polygon\", \"ETH\", \"MATIC\", 1000000000000000000 ) if bridge_result[\"success\"]: print(f\"Bridge quote: {bridge_result['result']}\") else: print(f\"Bridge operation failed: {bridge_result['error']}\")","title":"Blockchain Operation Safety"},{"location":"blockchain/#api-reference-summary","text":"","title":"API Reference Summary"},{"location":"blockchain/#available-modules","text":"Module Description Key Methods bridge Cross-chain bridging get_quote() , bridge_transfer() , get_multi_chain_asset_view() swap DeFi token swaps get_quote() , execute_swap() , cancel_swap() nfts NFT management list_nfts() , mint_nft() , batch_transfer() , burn_nft() governance DAO governance create_proposal() , cast_vote() , get_proposal_state() identity Decentralized identity get_did() , issue_credential() , verify_credential() reputation Soulbound tokens issue_sbt() , get_sbt_owner() marketplace NFT marketplace create_listing() , place_bid() , accept_bid() child_assets Child agent assets list_child_assets() , create_child_asset()","title":"Available Modules"},{"location":"blockchain/#common-response-patterns","text":"All blockchain operations return transaction hashes and operation IDs for tracking: { \"transaction_hash\": \"0x1234567890abcdef...\", \"operation_id\": \"op_123\", \"status\": \"pending\" | \"confirmed\" | \"failed\", \"block_number\": 12345678, \"gas_used\": 21000 }","title":"Common Response Patterns"},{"location":"email/","text":"CirtusAI SDK Email Services Guide Overview The CirtusAI SDK provides comprehensive email services with AI-powered features including inbox management, email sending, automated summarization, and integration with agent-based workflows. The email system supports multiple providers and includes advanced LangChain integration for intelligent email processing. Features Multi-Provider Support : Gmail, Outlook, and other email providers Agent-Based Access : Permission-controlled email access for child agents AI-Powered Summarization : Automated email content analysis and summarization LangChain Integration : Advanced email processing tools Real-Time Processing : Live email monitoring and processing Secure Authentication : OAuth2 and secure token management Basic Email Operations Reading Emails from cirtusai import CirtusAIClient client = CirtusAIClient(\"https://api.cirtusai.com\") client.set_token(\"your_access_token\") # Read inbox for a specific agent agent_id = \"child_agent_123\" messages = client.email.read_inbox(agent_id) for message in messages: print(f\"From: {message.get('from', 'Unknown')}\") print(f\"Subject: {message.get('subject', 'No Subject')}\") print(f\"Date: {message.get('date')}\") print(f\"Body: {message.get('text_body', '')[:200]}...\") print(\"-\" * 50) Sending Emails # Send email from agent email_result = client.email.send_email( agent_id=\"child_agent_123\", recipient=\"recipient@example.com\", subject=\"Automated Email from CirtusAI Agent\", body=\"This is an automated email sent using the CirtusAI SDK.\" ) print(f\"Email sent: {email_result['success']}\") print(f\"Message ID: {email_result.get('message_id')}\") AI-Powered Email Processing Email Summarization Tool The SDK includes a powerful LangChain-based email summarization tool: from cirtusai.email import EmailSummarizerTool from langchain_deepseek import ChatDeepSeek # Setup the email summarizer llm = ChatDeepSeek( api_key=\"your_deepseek_api_key\", model=\"deepseek-chat\" ) email_tool = EmailSummarizerTool( llm=llm, client=client, agent_id=\"child_agent_123\", username=\"your_username\", password=\"your_password\" ) # Execute email summarization summary_result = email_tool._run() print(summary_result) Custom Email Processing def process_emails_with_ai(client, agent_id, llm): \"\"\"Custom email processing with AI analysis\"\"\" # Read recent emails messages = client.email.read_inbox(agent_id) if not messages: return \"No new emails to process\" processed_emails = [] for message in messages: email_content = message.get('text_body', '') sender = message.get('from', 'Unknown') subject = message.get('subject', 'No Subject') # AI-powered analysis analysis_prompt = f\"\"\" Analyze the following email and provide: 1. Sentiment (positive/negative/neutral) 2. Priority level (high/medium/low) 3. Action required (yes/no) 4. Category (business/personal/marketing/support) Email: From: {sender} Subject: {subject} Content: {email_content} \"\"\" analysis = llm.invoke(analysis_prompt).content # Generate summary summary_prompt = f\"Summarize this email in one sentence: {email_content}\" summary = llm.invoke(summary_prompt).content processed_emails.append({ \"from\": sender, \"subject\": subject, \"summary\": summary, \"analysis\": analysis, \"original_content\": email_content[:500] # First 500 chars }) return processed_emails # Usage from langchain_deepseek import ChatDeepSeek llm = ChatDeepSeek(api_key=\"your_deepseek_api_key\") processed = process_emails_with_ai(client, \"child_agent_123\", llm) for email in processed: print(f\"From: {email['from']}\") print(f\"Subject: {email['subject']}\") print(f\"Summary: {email['summary']}\") print(f\"Analysis: {email['analysis']}\") print(\"-\" * 50) Advanced Email Workflows Automated Email Response System def setup_auto_responder(client, agent_id, llm, response_templates): \"\"\"Setup automated email response system\"\"\" def classify_email(content, subject): \"\"\"Classify email to determine response template\"\"\" classification_prompt = f\"\"\" Classify this email into one of these categories: - support_request - business_inquiry - appointment_request - general_question - spam Email Subject: {subject} Content: {content} Return only the category name. \"\"\" category = llm.invoke(classification_prompt).content.strip().lower() return category def generate_response(category, original_content, sender): \"\"\"Generate personalized response based on category\"\"\" if category not in response_templates: category = \"general_question\" template = response_templates[category] personalization_prompt = f\"\"\" Personalize this email template based on the original email: Template: {template} Original Email: {original_content} Sender: {sender} Make it sound natural and address specific points from the original email. \"\"\" personalized_response = llm.invoke(personalization_prompt).content return personalized_response # Main processing loop messages = client.email.read_inbox(agent_id) for message in messages: content = message.get('text_body', '') subject = message.get('subject', '') sender = message.get('from', '') # Skip if already processed (you'd implement this logic) if message.get('processed'): continue # Classify and generate response category = classify_email(content, subject) if category != 'spam': response = generate_response(category, content, sender) # Send automated response client.email.send_email( agent_id=agent_id, recipient=sender, subject=f\"Re: {subject}\", body=response ) print(f\"Auto-responded to {sender} - Category: {category}\") # Response templates templates = { \"support_request\": \"Thank you for reaching out. We've received your support request and will respond within 24 hours.\", \"business_inquiry\": \"Thank you for your business inquiry. We'll review your request and get back to you shortly.\", \"appointment_request\": \"We've received your appointment request. Please check your calendar for available slots.\", \"general_question\": \"Thank you for your email. We'll review your question and provide a response soon.\" } # Setup auto-responder setup_auto_responder(client, \"child_agent_123\", llm, templates) Email Analytics and Reporting def analyze_email_patterns(client, agent_id, llm, days=30): \"\"\"Analyze email patterns and generate insights\"\"\" # Get emails (in a real implementation, you'd filter by date) messages = client.email.read_inbox(agent_id) if not messages: return {\"error\": \"No emails found for analysis\"} # Collect email data email_data = [] for message in messages: email_data.append({ \"sender\": message.get('from', ''), \"subject\": message.get('subject', ''), \"content\": message.get('text_body', ''), \"date\": message.get('date', ''), \"length\": len(message.get('text_body', '')) }) # Generate analytics analysis_prompt = f\"\"\" Analyze these {len(email_data)} emails and provide insights: 1. Most common email types/categories 2. Busiest senders 3. Average email length 4. Common themes or topics 5. Response time requirements Email subjects: {[email['subject'] for email in email_data[:10]]} Provide a structured analysis report. \"\"\" insights = llm.invoke(analysis_prompt).content # Basic statistics total_emails = len(email_data) avg_length = sum(email['length'] for email in email_data) / total_emails unique_senders = len(set(email['sender'] for email in email_data)) return { \"total_emails\": total_emails, \"unique_senders\": unique_senders, \"average_length\": avg_length, \"ai_insights\": insights, \"period_days\": days } # Usage analytics = analyze_email_patterns(client, \"child_agent_123\", llm) print(f\"Email Analytics Report:\") print(f\"Total Emails: {analytics['total_emails']}\") print(f\"Unique Senders: {analytics['unique_senders']}\") print(f\"Average Length: {analytics['average_length']:.0f} characters\") print(f\"\\nAI Insights:\\n{analytics['ai_insights']}\") Email-Driven Task Automation def setup_email_task_automation(client, agent_id, llm): \"\"\"Setup email-driven task automation\"\"\" def extract_tasks_from_email(content, subject, sender): \"\"\"Extract actionable tasks from email content\"\"\" task_extraction_prompt = f\"\"\" Extract actionable tasks from this email. Return as a JSON list of tasks. Each task should have: description, priority (high/medium/low), deadline (if mentioned). From: {sender} Subject: {subject} Content: {content} Example format: [ { \"description\": \"Schedule meeting with client\", \"priority\": \"high\", \"deadline\": \"this week\" } ] \"\"\" tasks_json = llm.invoke(task_extraction_prompt).content try: # Parse JSON (you'd want better error handling) import json tasks = json.loads(tasks_json) return tasks except: return [] def create_calendar_event(task): \"\"\"Create calendar event for task (mock implementation)\"\"\" print(f\"\ud83d\udcc5 Created calendar event: {task['description']}\") return {\"event_id\": f\"event_{hash(task['description'])}\", \"status\": \"created\"} def send_task_confirmation(sender, tasks): \"\"\"Send confirmation email with extracted tasks\"\"\" task_list = \"\\n\".join([f\"- {task['description']} (Priority: {task['priority']})\" for task in tasks]) confirmation_body = f\"\"\" Thank you for your email. I've extracted the following tasks: {task_list} I'll work on these and update you on progress. Best regards, CirtusAI Assistant \"\"\" client.email.send_email( agent_id=agent_id, recipient=sender, subject=\"Task Confirmation - Action Items Extracted\", body=confirmation_body ) # Process emails for task extraction messages = client.email.read_inbox(agent_id) for message in messages: content = message.get('text_body', '') subject = message.get('subject', '') sender = message.get('from', '') # Extract tasks tasks = extract_tasks_from_email(content, subject, sender) if tasks: print(f\"Extracted {len(tasks)} tasks from email from {sender}\") # Create calendar events for task in tasks: create_calendar_event(task) # Send confirmation send_task_confirmation(sender, tasks) # Setup task automation setup_email_task_automation(client, \"child_agent_123\", llm) Integration with Other SDK Components Email + Wallet Integration def setup_financial_email_monitoring(client, agent_id, llm): \"\"\"Monitor emails for financial information and trigger wallet actions\"\"\" messages = client.email.read_inbox(agent_id) for message in messages: content = message.get('text_body', '') subject = message.get('subject', '') # Check for financial keywords financial_keywords = ['payment', 'invoice', 'transfer', 'crypto', 'wallet', 'transaction'] if any(keyword in content.lower() or keyword in subject.lower() for keyword in financial_keywords): # Extract financial information using AI financial_prompt = f\"\"\" Extract financial information from this email: - Amount (if mentioned) - Currency/Token - Transaction type (payment/receipt/request) - Wallet address (if any) Email: {content} Return as structured data. \"\"\" financial_info = llm.invoke(financial_prompt).content print(f\"Financial email detected from {message.get('from')}:\") print(f\"Analysis: {financial_info}\") # You could trigger wallet operations here # For example, check balances, prepare transactions, etc. try: wallets = client.wallets.list_wallets() print(f\"Available wallets: {len(wallets)}\") except Exception as e: print(f\"Could not access wallet info: {e}\") # Setup financial monitoring setup_financial_email_monitoring(client, \"child_agent_123\", llm) Email + Agent Management def email_driven_agent_creation(client, master_agent_id, llm): \"\"\"Create child agents based on email requests\"\"\" messages = client.email.read_inbox(master_agent_id) for message in messages: content = message.get('text_body', '') subject = message.get('subject', '') sender = message.get('from', '') # Check if email is requesting agent creation if 'create agent' in content.lower() or 'new agent' in content.lower(): # Extract agent requirements using AI agent_prompt = f\"\"\" Extract agent creation requirements from this email: - Agent name/purpose - Required permissions - Needed assets (email/wallet) Email content: {content} Return as structured requirements. \"\"\" requirements = llm.invoke(agent_prompt).content print(f\"Agent creation request from {sender}:\") print(f\"Requirements: {requirements}\") # Create child agent (simplified) try: child_agent = client.agents.create_child_agent( parent_id=master_agent_id, name=f\"Agent for {sender}\", permissions_granted=[\"email:read\", \"email:send\"] ) # Send confirmation client.email.send_email( agent_id=master_agent_id, recipient=sender, subject=\"Agent Created Successfully\", body=f\"Your requested agent has been created with ID: {child_agent['id']}\" ) except Exception as e: print(f\"Failed to create agent: {e}\") # Setup agent creation automation email_driven_agent_creation(client, \"master_agent_123\", llm) Error Handling and Best Practices Robust Email Processing def safe_email_operation(client, operation, *args, **kwargs): \"\"\"Safely execute email operations with proper error handling\"\"\" try: result = getattr(client.email, operation)(*args, **kwargs) return {\"success\": True, \"result\": result} except requests.exceptions.HTTPError as e: error_code = e.response.status_code if error_code == 403: return {\"success\": False, \"error\": \"Permission denied - check agent email permissions\"} elif error_code == 404: return {\"success\": False, \"error\": \"Agent not found or email not configured\"} else: return {\"success\": False, \"error\": f\"HTTP {error_code}: {e}\"} except Exception as e: return {\"success\": False, \"error\": f\"Unexpected error: {str(e)}\"} # Usage result = safe_email_operation(client, \"read_inbox\", \"child_agent_123\") if result[\"success\"]: messages = result[\"result\"] print(f\"Retrieved {len(messages)} messages\") else: print(f\"Email operation failed: {result['error']}\") Email Processing Best Practices class EmailManager: \"\"\"Best practices for email management\"\"\" def __init__(self, client, llm=None): self.client = client self.llm = llm self.processed_emails = set() # Track processed emails def batch_process_emails(self, agent_id, batch_size=10): \"\"\"Process emails in batches to avoid overload\"\"\" messages = self.client.email.read_inbox(agent_id) # Process in batches for i in range(0, len(messages), batch_size): batch = messages[i:i + batch_size] for message in batch: message_id = message.get('id', hash(message.get('subject', ''))) if message_id in self.processed_emails: continue try: self.process_single_email(agent_id, message) self.processed_emails.add(message_id) except Exception as e: print(f\"Failed to process email {message_id}: {e}\") def process_single_email(self, agent_id, message): \"\"\"Process a single email with full error handling\"\"\" sender = message.get('from', '') subject = message.get('subject', '') content = message.get('text_body', '') print(f\"Processing email from {sender}: {subject}\") # Add your processing logic here if self.llm: summary = self.llm.invoke(f\"Summarize: {content}\").content print(f\"Summary: {summary}\") def cleanup_old_emails(self, days=30): \"\"\"Clean up old processed email records\"\"\" # In a real implementation, you'd clean up old entries # based on timestamps pass # Usage email_manager = EmailManager(client, llm) email_manager.batch_process_emails(\"child_agent_123\") API Reference EmailClient Methods Method Description Parameters Returns read_inbox() Read email inbox for agent agent_id List[Dict] send_email() Send email from agent agent_id, recipient, subject, body Dict EmailSummarizerTool Property Description Type name Tool identifier str description Tool description str llm LangChain LLM instance ChatDeepSeek client CirtusAI client instance CirtusAIClient agent_id Agent ID for email access str username Authentication username str password Authentication password str Email Message Structure { \"id\": \"message_123\", \"from\": \"sender@example.com\", \"to\": \"recipient@example.com\", \"subject\": \"Email Subject\", \"text_body\": \"Email content...\", \"html_body\": \"<html>Email content...</html>\", \"date\": \"2024-01-15T10:30:00Z\", \"attachments\": [], \"processed\": false } Required Permissions email:read - Required to read inbox email:send - Required to send emails LangChain Integration The email system integrates seamlessly with LangChain for advanced AI processing: from langchain_core.tools import BaseTool from langchain_deepseek import ChatDeepSeek # The EmailSummarizerTool extends BaseTool # and can be used in LangChain agent workflows","title":"Email Services"},{"location":"email/#cirtusai-sdk-email-services-guide","text":"","title":"CirtusAI SDK Email Services Guide"},{"location":"email/#overview","text":"The CirtusAI SDK provides comprehensive email services with AI-powered features including inbox management, email sending, automated summarization, and integration with agent-based workflows. The email system supports multiple providers and includes advanced LangChain integration for intelligent email processing.","title":"Overview"},{"location":"email/#features","text":"Multi-Provider Support : Gmail, Outlook, and other email providers Agent-Based Access : Permission-controlled email access for child agents AI-Powered Summarization : Automated email content analysis and summarization LangChain Integration : Advanced email processing tools Real-Time Processing : Live email monitoring and processing Secure Authentication : OAuth2 and secure token management","title":"Features"},{"location":"email/#basic-email-operations","text":"","title":"Basic Email Operations"},{"location":"email/#reading-emails","text":"from cirtusai import CirtusAIClient client = CirtusAIClient(\"https://api.cirtusai.com\") client.set_token(\"your_access_token\") # Read inbox for a specific agent agent_id = \"child_agent_123\" messages = client.email.read_inbox(agent_id) for message in messages: print(f\"From: {message.get('from', 'Unknown')}\") print(f\"Subject: {message.get('subject', 'No Subject')}\") print(f\"Date: {message.get('date')}\") print(f\"Body: {message.get('text_body', '')[:200]}...\") print(\"-\" * 50)","title":"Reading Emails"},{"location":"email/#sending-emails","text":"# Send email from agent email_result = client.email.send_email( agent_id=\"child_agent_123\", recipient=\"recipient@example.com\", subject=\"Automated Email from CirtusAI Agent\", body=\"This is an automated email sent using the CirtusAI SDK.\" ) print(f\"Email sent: {email_result['success']}\") print(f\"Message ID: {email_result.get('message_id')}\")","title":"Sending Emails"},{"location":"email/#ai-powered-email-processing","text":"","title":"AI-Powered Email Processing"},{"location":"email/#email-summarization-tool","text":"The SDK includes a powerful LangChain-based email summarization tool: from cirtusai.email import EmailSummarizerTool from langchain_deepseek import ChatDeepSeek # Setup the email summarizer llm = ChatDeepSeek( api_key=\"your_deepseek_api_key\", model=\"deepseek-chat\" ) email_tool = EmailSummarizerTool( llm=llm, client=client, agent_id=\"child_agent_123\", username=\"your_username\", password=\"your_password\" ) # Execute email summarization summary_result = email_tool._run() print(summary_result)","title":"Email Summarization Tool"},{"location":"email/#custom-email-processing","text":"def process_emails_with_ai(client, agent_id, llm): \"\"\"Custom email processing with AI analysis\"\"\" # Read recent emails messages = client.email.read_inbox(agent_id) if not messages: return \"No new emails to process\" processed_emails = [] for message in messages: email_content = message.get('text_body', '') sender = message.get('from', 'Unknown') subject = message.get('subject', 'No Subject') # AI-powered analysis analysis_prompt = f\"\"\" Analyze the following email and provide: 1. Sentiment (positive/negative/neutral) 2. Priority level (high/medium/low) 3. Action required (yes/no) 4. Category (business/personal/marketing/support) Email: From: {sender} Subject: {subject} Content: {email_content} \"\"\" analysis = llm.invoke(analysis_prompt).content # Generate summary summary_prompt = f\"Summarize this email in one sentence: {email_content}\" summary = llm.invoke(summary_prompt).content processed_emails.append({ \"from\": sender, \"subject\": subject, \"summary\": summary, \"analysis\": analysis, \"original_content\": email_content[:500] # First 500 chars }) return processed_emails # Usage from langchain_deepseek import ChatDeepSeek llm = ChatDeepSeek(api_key=\"your_deepseek_api_key\") processed = process_emails_with_ai(client, \"child_agent_123\", llm) for email in processed: print(f\"From: {email['from']}\") print(f\"Subject: {email['subject']}\") print(f\"Summary: {email['summary']}\") print(f\"Analysis: {email['analysis']}\") print(\"-\" * 50)","title":"Custom Email Processing"},{"location":"email/#advanced-email-workflows","text":"","title":"Advanced Email Workflows"},{"location":"email/#automated-email-response-system","text":"def setup_auto_responder(client, agent_id, llm, response_templates): \"\"\"Setup automated email response system\"\"\" def classify_email(content, subject): \"\"\"Classify email to determine response template\"\"\" classification_prompt = f\"\"\" Classify this email into one of these categories: - support_request - business_inquiry - appointment_request - general_question - spam Email Subject: {subject} Content: {content} Return only the category name. \"\"\" category = llm.invoke(classification_prompt).content.strip().lower() return category def generate_response(category, original_content, sender): \"\"\"Generate personalized response based on category\"\"\" if category not in response_templates: category = \"general_question\" template = response_templates[category] personalization_prompt = f\"\"\" Personalize this email template based on the original email: Template: {template} Original Email: {original_content} Sender: {sender} Make it sound natural and address specific points from the original email. \"\"\" personalized_response = llm.invoke(personalization_prompt).content return personalized_response # Main processing loop messages = client.email.read_inbox(agent_id) for message in messages: content = message.get('text_body', '') subject = message.get('subject', '') sender = message.get('from', '') # Skip if already processed (you'd implement this logic) if message.get('processed'): continue # Classify and generate response category = classify_email(content, subject) if category != 'spam': response = generate_response(category, content, sender) # Send automated response client.email.send_email( agent_id=agent_id, recipient=sender, subject=f\"Re: {subject}\", body=response ) print(f\"Auto-responded to {sender} - Category: {category}\") # Response templates templates = { \"support_request\": \"Thank you for reaching out. We've received your support request and will respond within 24 hours.\", \"business_inquiry\": \"Thank you for your business inquiry. We'll review your request and get back to you shortly.\", \"appointment_request\": \"We've received your appointment request. Please check your calendar for available slots.\", \"general_question\": \"Thank you for your email. We'll review your question and provide a response soon.\" } # Setup auto-responder setup_auto_responder(client, \"child_agent_123\", llm, templates)","title":"Automated Email Response System"},{"location":"email/#email-analytics-and-reporting","text":"def analyze_email_patterns(client, agent_id, llm, days=30): \"\"\"Analyze email patterns and generate insights\"\"\" # Get emails (in a real implementation, you'd filter by date) messages = client.email.read_inbox(agent_id) if not messages: return {\"error\": \"No emails found for analysis\"} # Collect email data email_data = [] for message in messages: email_data.append({ \"sender\": message.get('from', ''), \"subject\": message.get('subject', ''), \"content\": message.get('text_body', ''), \"date\": message.get('date', ''), \"length\": len(message.get('text_body', '')) }) # Generate analytics analysis_prompt = f\"\"\" Analyze these {len(email_data)} emails and provide insights: 1. Most common email types/categories 2. Busiest senders 3. Average email length 4. Common themes or topics 5. Response time requirements Email subjects: {[email['subject'] for email in email_data[:10]]} Provide a structured analysis report. \"\"\" insights = llm.invoke(analysis_prompt).content # Basic statistics total_emails = len(email_data) avg_length = sum(email['length'] for email in email_data) / total_emails unique_senders = len(set(email['sender'] for email in email_data)) return { \"total_emails\": total_emails, \"unique_senders\": unique_senders, \"average_length\": avg_length, \"ai_insights\": insights, \"period_days\": days } # Usage analytics = analyze_email_patterns(client, \"child_agent_123\", llm) print(f\"Email Analytics Report:\") print(f\"Total Emails: {analytics['total_emails']}\") print(f\"Unique Senders: {analytics['unique_senders']}\") print(f\"Average Length: {analytics['average_length']:.0f} characters\") print(f\"\\nAI Insights:\\n{analytics['ai_insights']}\")","title":"Email Analytics and Reporting"},{"location":"email/#email-driven-task-automation","text":"def setup_email_task_automation(client, agent_id, llm): \"\"\"Setup email-driven task automation\"\"\" def extract_tasks_from_email(content, subject, sender): \"\"\"Extract actionable tasks from email content\"\"\" task_extraction_prompt = f\"\"\" Extract actionable tasks from this email. Return as a JSON list of tasks. Each task should have: description, priority (high/medium/low), deadline (if mentioned). From: {sender} Subject: {subject} Content: {content} Example format: [ { \"description\": \"Schedule meeting with client\", \"priority\": \"high\", \"deadline\": \"this week\" } ] \"\"\" tasks_json = llm.invoke(task_extraction_prompt).content try: # Parse JSON (you'd want better error handling) import json tasks = json.loads(tasks_json) return tasks except: return [] def create_calendar_event(task): \"\"\"Create calendar event for task (mock implementation)\"\"\" print(f\"\ud83d\udcc5 Created calendar event: {task['description']}\") return {\"event_id\": f\"event_{hash(task['description'])}\", \"status\": \"created\"} def send_task_confirmation(sender, tasks): \"\"\"Send confirmation email with extracted tasks\"\"\" task_list = \"\\n\".join([f\"- {task['description']} (Priority: {task['priority']})\" for task in tasks]) confirmation_body = f\"\"\" Thank you for your email. I've extracted the following tasks: {task_list} I'll work on these and update you on progress. Best regards, CirtusAI Assistant \"\"\" client.email.send_email( agent_id=agent_id, recipient=sender, subject=\"Task Confirmation - Action Items Extracted\", body=confirmation_body ) # Process emails for task extraction messages = client.email.read_inbox(agent_id) for message in messages: content = message.get('text_body', '') subject = message.get('subject', '') sender = message.get('from', '') # Extract tasks tasks = extract_tasks_from_email(content, subject, sender) if tasks: print(f\"Extracted {len(tasks)} tasks from email from {sender}\") # Create calendar events for task in tasks: create_calendar_event(task) # Send confirmation send_task_confirmation(sender, tasks) # Setup task automation setup_email_task_automation(client, \"child_agent_123\", llm)","title":"Email-Driven Task Automation"},{"location":"email/#integration-with-other-sdk-components","text":"","title":"Integration with Other SDK Components"},{"location":"email/#email-wallet-integration","text":"def setup_financial_email_monitoring(client, agent_id, llm): \"\"\"Monitor emails for financial information and trigger wallet actions\"\"\" messages = client.email.read_inbox(agent_id) for message in messages: content = message.get('text_body', '') subject = message.get('subject', '') # Check for financial keywords financial_keywords = ['payment', 'invoice', 'transfer', 'crypto', 'wallet', 'transaction'] if any(keyword in content.lower() or keyword in subject.lower() for keyword in financial_keywords): # Extract financial information using AI financial_prompt = f\"\"\" Extract financial information from this email: - Amount (if mentioned) - Currency/Token - Transaction type (payment/receipt/request) - Wallet address (if any) Email: {content} Return as structured data. \"\"\" financial_info = llm.invoke(financial_prompt).content print(f\"Financial email detected from {message.get('from')}:\") print(f\"Analysis: {financial_info}\") # You could trigger wallet operations here # For example, check balances, prepare transactions, etc. try: wallets = client.wallets.list_wallets() print(f\"Available wallets: {len(wallets)}\") except Exception as e: print(f\"Could not access wallet info: {e}\") # Setup financial monitoring setup_financial_email_monitoring(client, \"child_agent_123\", llm)","title":"Email + Wallet Integration"},{"location":"email/#email-agent-management","text":"def email_driven_agent_creation(client, master_agent_id, llm): \"\"\"Create child agents based on email requests\"\"\" messages = client.email.read_inbox(master_agent_id) for message in messages: content = message.get('text_body', '') subject = message.get('subject', '') sender = message.get('from', '') # Check if email is requesting agent creation if 'create agent' in content.lower() or 'new agent' in content.lower(): # Extract agent requirements using AI agent_prompt = f\"\"\" Extract agent creation requirements from this email: - Agent name/purpose - Required permissions - Needed assets (email/wallet) Email content: {content} Return as structured requirements. \"\"\" requirements = llm.invoke(agent_prompt).content print(f\"Agent creation request from {sender}:\") print(f\"Requirements: {requirements}\") # Create child agent (simplified) try: child_agent = client.agents.create_child_agent( parent_id=master_agent_id, name=f\"Agent for {sender}\", permissions_granted=[\"email:read\", \"email:send\"] ) # Send confirmation client.email.send_email( agent_id=master_agent_id, recipient=sender, subject=\"Agent Created Successfully\", body=f\"Your requested agent has been created with ID: {child_agent['id']}\" ) except Exception as e: print(f\"Failed to create agent: {e}\") # Setup agent creation automation email_driven_agent_creation(client, \"master_agent_123\", llm)","title":"Email + Agent Management"},{"location":"email/#error-handling-and-best-practices","text":"","title":"Error Handling and Best Practices"},{"location":"email/#robust-email-processing","text":"def safe_email_operation(client, operation, *args, **kwargs): \"\"\"Safely execute email operations with proper error handling\"\"\" try: result = getattr(client.email, operation)(*args, **kwargs) return {\"success\": True, \"result\": result} except requests.exceptions.HTTPError as e: error_code = e.response.status_code if error_code == 403: return {\"success\": False, \"error\": \"Permission denied - check agent email permissions\"} elif error_code == 404: return {\"success\": False, \"error\": \"Agent not found or email not configured\"} else: return {\"success\": False, \"error\": f\"HTTP {error_code}: {e}\"} except Exception as e: return {\"success\": False, \"error\": f\"Unexpected error: {str(e)}\"} # Usage result = safe_email_operation(client, \"read_inbox\", \"child_agent_123\") if result[\"success\"]: messages = result[\"result\"] print(f\"Retrieved {len(messages)} messages\") else: print(f\"Email operation failed: {result['error']}\")","title":"Robust Email Processing"},{"location":"email/#email-processing-best-practices","text":"class EmailManager: \"\"\"Best practices for email management\"\"\" def __init__(self, client, llm=None): self.client = client self.llm = llm self.processed_emails = set() # Track processed emails def batch_process_emails(self, agent_id, batch_size=10): \"\"\"Process emails in batches to avoid overload\"\"\" messages = self.client.email.read_inbox(agent_id) # Process in batches for i in range(0, len(messages), batch_size): batch = messages[i:i + batch_size] for message in batch: message_id = message.get('id', hash(message.get('subject', ''))) if message_id in self.processed_emails: continue try: self.process_single_email(agent_id, message) self.processed_emails.add(message_id) except Exception as e: print(f\"Failed to process email {message_id}: {e}\") def process_single_email(self, agent_id, message): \"\"\"Process a single email with full error handling\"\"\" sender = message.get('from', '') subject = message.get('subject', '') content = message.get('text_body', '') print(f\"Processing email from {sender}: {subject}\") # Add your processing logic here if self.llm: summary = self.llm.invoke(f\"Summarize: {content}\").content print(f\"Summary: {summary}\") def cleanup_old_emails(self, days=30): \"\"\"Clean up old processed email records\"\"\" # In a real implementation, you'd clean up old entries # based on timestamps pass # Usage email_manager = EmailManager(client, llm) email_manager.batch_process_emails(\"child_agent_123\")","title":"Email Processing Best Practices"},{"location":"email/#api-reference","text":"","title":"API Reference"},{"location":"email/#emailclient-methods","text":"Method Description Parameters Returns read_inbox() Read email inbox for agent agent_id List[Dict] send_email() Send email from agent agent_id, recipient, subject, body Dict","title":"EmailClient Methods"},{"location":"email/#emailsummarizertool","text":"Property Description Type name Tool identifier str description Tool description str llm LangChain LLM instance ChatDeepSeek client CirtusAI client instance CirtusAIClient agent_id Agent ID for email access str username Authentication username str password Authentication password str","title":"EmailSummarizerTool"},{"location":"email/#email-message-structure","text":"{ \"id\": \"message_123\", \"from\": \"sender@example.com\", \"to\": \"recipient@example.com\", \"subject\": \"Email Subject\", \"text_body\": \"Email content...\", \"html_body\": \"<html>Email content...</html>\", \"date\": \"2024-01-15T10:30:00Z\", \"attachments\": [], \"processed\": false }","title":"Email Message Structure"},{"location":"email/#required-permissions","text":"email:read - Required to read inbox email:send - Required to send emails","title":"Required Permissions"},{"location":"email/#langchain-integration","text":"The email system integrates seamlessly with LangChain for advanced AI processing: from langchain_core.tools import BaseTool from langchain_deepseek import ChatDeepSeek # The EmailSummarizerTool extends BaseTool # and can be used in LangChain agent workflows","title":"LangChain Integration"},{"location":"quickstart/","text":"CirtusAI SDK Quick Start Guide Installation pip install cirtusai-sdk Basic Setup from cirtusai import CirtusAIClient # Initialize client client = CirtusAIClient(\"https://api.cirtusai.com\") # Authenticate token = client.auth.login(\"your_username\", \"your_password\") client.set_token(token.access_token) 5-Minute Examples 1. Create and Use an Agent (2 minutes) # Create a child agent agent = client.agents.create_child_agent( parent_id=\"your_master_agent_id\", name=\"My First Agent\", permissions_granted=[\"email:read\", \"email:send\"] ) # Provision email for the agent email_asset = client.agents.provision_email(agent['id']) print(f\"Agent email: {email_asset['email_address']}\") # Read emails messages = client.email.read_inbox(agent['id']) print(f\"Found {len(messages)} messages\") 2. Create and Fund a Wallet (1 minute) # Create wallet wallet = client.wallets.create_wallet(\"ethereum\") print(f\"Wallet address: {wallet['address']}\") # Check balance balance = client.wallets.get_balance(\"ethereum\", wallet['address']) print(f\"ETH balance: {balance}\") 3. Bridge Assets Cross-Chain (2 minutes) # Get bridge quote quote = client.bridge.get_quote( from_chain=\"ethereum\", to_chain=\"polygon\", from_token=\"ETH\", to_token=\"MATIC\", amount=1000000000000000000 # 1 ETH ) print(f\"Will receive: {quote['estimated_output']} MATIC\") # Execute bridge (if you have funds) # bridge_result = client.bridge.bridge_transfer(...) Common Workflows Email + AI Processing from langchain_deepseek import ChatDeepSeek # Setup AI llm = ChatDeepSeek(api_key=\"your_deepseek_key\") # Process emails with AI messages = client.email.read_inbox(\"agent_id\") for message in messages: summary = llm.invoke(f\"Summarize: {message['text_body']}\").content print(f\"From: {message['from']}\") print(f\"Summary: {summary}\") DeFi Operations # Get swap quote quote = client.swap.get_quote( from_chain=\"ethereum\", to_chain=\"ethereum\", from_token=\"USDC\", to_token=\"ETH\", amount=1000.0 ) # Execute swap swap_result = client.swap.execute_swap({ \"from_token\": \"USDC\", \"to_token\": \"ETH\", \"amount\": 1000.0, \"slippage_tolerance\": 0.5 }) NFT Management # List your NFTs nfts = client.nfts.list_nfts(\"wallet_id\") # Create marketplace listing listing = client.marketplace.create_listing({ \"nft_contract\": nfts[0]['contract_address'], \"token_id\": nfts[0]['token_id'], \"price\": \"0.1\", \"currency\": \"ETH\" }) Error Handling try: result = client.some_operation() except requests.exceptions.HTTPError as e: if e.response.status_code == 403: print(\"Permission denied\") elif e.response.status_code == 401: print(\"Authentication required\") else: print(f\"Error: {e}\") Next Steps Read the full documentation : Explore detailed guides for each component Set up 2FA : Enable two-factor authentication for security Create agent workflows : Build complex automation with multiple agents Integrate with LangChain : Add AI capabilities to your agents Explore DeFi : Use cross-chain bridging and swapping features Quick Reference Core Modules client.auth - Authentication and 2FA client.agents - Agent management client.wallets - Wallet and asset operations client.email - Email services client.security - KYC/AML compliance client.bridge - Cross-chain bridging client.swap - DeFi swaps client.nfts - NFT operations client.marketplace - NFT marketplace client.governance - DAO governance client.identity - Decentralized identity client.reputation - Soulbound tokens Common Patterns # Safe operation wrapper def safe_operation(operation): try: return {\"success\": True, \"result\": operation()} except Exception as e: return {\"success\": False, \"error\": str(e)} # Batch processing def process_batch(items, operation, batch_size=10): results = [] for i in range(0, len(items), batch_size): batch = items[i:i + batch_size] for item in batch: result = safe_operation(lambda: operation(item)) results.append(result) return results Support Documentation : See /docs/ folder for detailed guides Examples : Check /examples/ folder for complete workflows Issues : Report bugs and feature requests on GitHub API Reference : Each module has detailed API documentation","title":"Quick Start"},{"location":"quickstart/#cirtusai-sdk-quick-start-guide","text":"","title":"CirtusAI SDK Quick Start Guide"},{"location":"quickstart/#installation","text":"pip install cirtusai-sdk","title":"Installation"},{"location":"quickstart/#basic-setup","text":"from cirtusai import CirtusAIClient # Initialize client client = CirtusAIClient(\"https://api.cirtusai.com\") # Authenticate token = client.auth.login(\"your_username\", \"your_password\") client.set_token(token.access_token)","title":"Basic Setup"},{"location":"quickstart/#5-minute-examples","text":"","title":"5-Minute Examples"},{"location":"quickstart/#1-create-and-use-an-agent-2-minutes","text":"# Create a child agent agent = client.agents.create_child_agent( parent_id=\"your_master_agent_id\", name=\"My First Agent\", permissions_granted=[\"email:read\", \"email:send\"] ) # Provision email for the agent email_asset = client.agents.provision_email(agent['id']) print(f\"Agent email: {email_asset['email_address']}\") # Read emails messages = client.email.read_inbox(agent['id']) print(f\"Found {len(messages)} messages\")","title":"1. Create and Use an Agent (2 minutes)"},{"location":"quickstart/#2-create-and-fund-a-wallet-1-minute","text":"# Create wallet wallet = client.wallets.create_wallet(\"ethereum\") print(f\"Wallet address: {wallet['address']}\") # Check balance balance = client.wallets.get_balance(\"ethereum\", wallet['address']) print(f\"ETH balance: {balance}\")","title":"2. Create and Fund a Wallet (1 minute)"},{"location":"quickstart/#3-bridge-assets-cross-chain-2-minutes","text":"# Get bridge quote quote = client.bridge.get_quote( from_chain=\"ethereum\", to_chain=\"polygon\", from_token=\"ETH\", to_token=\"MATIC\", amount=1000000000000000000 # 1 ETH ) print(f\"Will receive: {quote['estimated_output']} MATIC\") # Execute bridge (if you have funds) # bridge_result = client.bridge.bridge_transfer(...)","title":"3. Bridge Assets Cross-Chain (2 minutes)"},{"location":"quickstart/#common-workflows","text":"","title":"Common Workflows"},{"location":"quickstart/#email-ai-processing","text":"from langchain_deepseek import ChatDeepSeek # Setup AI llm = ChatDeepSeek(api_key=\"your_deepseek_key\") # Process emails with AI messages = client.email.read_inbox(\"agent_id\") for message in messages: summary = llm.invoke(f\"Summarize: {message['text_body']}\").content print(f\"From: {message['from']}\") print(f\"Summary: {summary}\")","title":"Email + AI Processing"},{"location":"quickstart/#defi-operations","text":"# Get swap quote quote = client.swap.get_quote( from_chain=\"ethereum\", to_chain=\"ethereum\", from_token=\"USDC\", to_token=\"ETH\", amount=1000.0 ) # Execute swap swap_result = client.swap.execute_swap({ \"from_token\": \"USDC\", \"to_token\": \"ETH\", \"amount\": 1000.0, \"slippage_tolerance\": 0.5 })","title":"DeFi Operations"},{"location":"quickstart/#nft-management","text":"# List your NFTs nfts = client.nfts.list_nfts(\"wallet_id\") # Create marketplace listing listing = client.marketplace.create_listing({ \"nft_contract\": nfts[0]['contract_address'], \"token_id\": nfts[0]['token_id'], \"price\": \"0.1\", \"currency\": \"ETH\" })","title":"NFT Management"},{"location":"quickstart/#error-handling","text":"try: result = client.some_operation() except requests.exceptions.HTTPError as e: if e.response.status_code == 403: print(\"Permission denied\") elif e.response.status_code == 401: print(\"Authentication required\") else: print(f\"Error: {e}\")","title":"Error Handling"},{"location":"quickstart/#next-steps","text":"Read the full documentation : Explore detailed guides for each component Set up 2FA : Enable two-factor authentication for security Create agent workflows : Build complex automation with multiple agents Integrate with LangChain : Add AI capabilities to your agents Explore DeFi : Use cross-chain bridging and swapping features","title":"Next Steps"},{"location":"quickstart/#quick-reference","text":"","title":"Quick Reference"},{"location":"quickstart/#core-modules","text":"client.auth - Authentication and 2FA client.agents - Agent management client.wallets - Wallet and asset operations client.email - Email services client.security - KYC/AML compliance client.bridge - Cross-chain bridging client.swap - DeFi swaps client.nfts - NFT operations client.marketplace - NFT marketplace client.governance - DAO governance client.identity - Decentralized identity client.reputation - Soulbound tokens","title":"Core Modules"},{"location":"quickstart/#common-patterns","text":"# Safe operation wrapper def safe_operation(operation): try: return {\"success\": True, \"result\": operation()} except Exception as e: return {\"success\": False, \"error\": str(e)} # Batch processing def process_batch(items, operation, batch_size=10): results = [] for i in range(0, len(items), batch_size): batch = items[i:i + batch_size] for item in batch: result = safe_operation(lambda: operation(item)) results.append(result) return results","title":"Common Patterns"},{"location":"quickstart/#support","text":"Documentation : See /docs/ folder for detailed guides Examples : Check /examples/ folder for complete workflows Issues : Report bugs and feature requests on GitHub API Reference : Each module has detailed API documentation","title":"Support"},{"location":"security/","text":"CirtusAI SDK Security & Compliance Guide Overview The CirtusAI SDK provides comprehensive security and compliance features including transaction monitoring, KYC verification, audit trails, compliance reporting, and regulatory adherence tools. The security system integrates with multiple providers and offers enterprise-grade compliance management. Features Transaction Monitoring : Real-time blockchain transaction surveillance KYC/AML Compliance : Identity verification and anti-money laundering checks Audit Trails : Comprehensive activity logging and integrity verification Compliance Reporting : Automated regulatory report generation Document Processing : AI-powered compliance document analysis Webhook Management : Real-time compliance event notifications Risk Assessment : Automated risk scoring and alerts Transaction Monitoring Address Monitoring from cirtusai import CirtusAIClient client = CirtusAIClient(\"https://api.cirtusai.com\") client.set_token(\"your_access_token\") # Watch specific address for suspicious activity watch_result = client.security.watch_address( address=\"0x742d35Cc6635C0532925a3b8D\", chain=\"ethereum\", provider=\"blocknative\" ) print(f\"Watch ID: {watch_result['watch_id']}\") print(f\"Status: {watch_result['status']}\") print(f\"Alert threshold: {watch_result['alert_threshold']}\") # List all active watches watches = client.security.list_watches() for watch in watches: print(f\"Watch ID: {watch['watch_id']}\") print(f\"Address: {watch['address']}\") print(f\"Chain: {watch['chain']}\") print(f\"Status: {watch['status']}\") Transaction Status Monitoring # Get transaction status and risk assessment tx_status = client.security.get_tx_status( tx_hash=\"0x1234567890abcdef\", provider=\"blocknative\" ) print(f\"Transaction status: {tx_status['status']}\") print(f\"Risk score: {tx_status['risk_score']}\") print(f\"AML alerts: {tx_status['aml_alerts']}\") # Alternative method status = client.security.get_transaction_status(\"0x1234567890abcdef\") print(f\"Confirmation status: {status}\") Security Alerts # Get security alerts for monitored addresses alerts = client.security.get_alerts() for alert in alerts: print(f\"Alert ID: {alert['alert_id']}\") print(f\"Type: {alert['alert_type']}\") print(f\"Severity: {alert['severity']}\") print(f\"Address: {alert['address']}\") print(f\"Description: {alert['description']}\") print(f\"Timestamp: {alert['timestamp']}\") KYC/AML Compliance KYC Status Management # Check current KYC status kyc_status = client.security.get_kyc_status() print(f\"KYC Status: {kyc_status['status']}\") print(f\"Verification level: {kyc_status['verification_level']}\") print(f\"Required documents: {kyc_status['required_documents']}\") # Initiate KYC process kyc_init = client.security.initiate_kyc() print(f\"KYC session ID: {kyc_init['session_id']}\") print(f\"Upload URL: {kyc_init['upload_url']}\") print(f\"Instructions: {kyc_init['instructions']}\") Automated KYC Processing # Auto-submit KYC for single user auto_kyc = client.security.auto_submit_kyc() print(f\"Submission status: {auto_kyc['status']}\") print(f\"Processing time: {auto_kyc['estimated_processing_time']}\") # Bulk auto-submit KYC for multiple users user_ids = [\"user_123\", \"user_456\", \"user_789\"] bulk_kyc = client.security.bulk_auto_submit_kyc(user_ids) print(f\"Batch ID: {bulk_kyc['batch_id']}\") print(f\"Submitted: {bulk_kyc['submitted_count']}\") print(f\"Failed: {bulk_kyc['failed_count']}\") Document Processing # Process compliance document with open(\"passport.pdf\", \"rb\") as doc_file: document_result = client.security.process_document( document_file=doc_file, document_type=\"passport\" ) print(f\"Document ID: {document_result['document_id']}\") print(f\"Verification status: {document_result['verification_status']}\") print(f\"Extracted data: {document_result['extracted_data']}\") print(f\"Confidence score: {document_result['confidence_score']}\") # Bulk document processing documents = [ {\"file\": \"passport.pdf\", \"type\": \"passport\"}, {\"file\": \"utility_bill.pdf\", \"type\": \"proof_of_address\"}, {\"file\": \"bank_statement.pdf\", \"type\": \"proof_of_income\"} ] bulk_results = client.security.bulk_document_processing(documents) for result in bulk_results: print(f\"Document: {result['document_type']}\") print(f\"Status: {result['verification_status']}\") print(f\"Issues: {result.get('issues', 'None')}\") Audit Trail Management Comprehensive Audit Logging # Get detailed audit trail audit_trail = client.security.get_audit_trail( start_date=\"2024-01-01\", end_date=\"2024-01-31\", entity_types=[\"user\", \"transaction\", \"document\"], action_types=[\"create\", \"update\", \"delete\", \"verify\"], user_ids=[\"user_123\"], limit=100 ) print(f\"Total entries: {len(audit_trail['entries'])}\") for entry in audit_trail['entries']: print(f\"Timestamp: {entry['timestamp']}\") print(f\"Action: {entry['action_type']}\") print(f\"Entity: {entry['entity_type']} - {entry['entity_id']}\") print(f\"User: {entry['user_id']}\") print(f\"Details: {entry['details']}\") Audit Integrity Verification # Verify audit trail integrity integrity_check = client.security.verify_audit_integrity() print(f\"Integrity status: {integrity_check['status']}\") print(f\"Total entries checked: {integrity_check['entries_checked']}\") print(f\"Hash verification: {integrity_check['hash_verification']}\") print(f\"Timestamp verification: {integrity_check['timestamp_verification']}\") if integrity_check['issues']: print(\"Integrity issues found:\") for issue in integrity_check['issues']: print(f\" - {issue['type']}: {issue['description']}\") Legacy Audit Trail Access # Access legacy audit trail for specific entity legacy_audit = client.security.get_audit_trail_legacy( entity_id=\"transaction_123\", entity_type=\"transaction\" ) print(f\"Entity: {legacy_audit['entity_id']}\") print(f\"Audit entries: {len(legacy_audit['audit_entries'])}\") for entry in legacy_audit['audit_entries']: print(f\" {entry['timestamp']}: {entry['action']} by {entry['user_id']}\") Compliance Reporting Automated Report Generation # Generate compliance report report = client.security.generate_report( start_date=\"2024-01-01\", end_date=\"2024-01-31\", report_type=\"aml_summary\" ) print(f\"Report ID: {report['report_id']}\") print(f\"Status: {report['status']}\") print(f\"Download URL: {report['download_url']}\") print(f\"Expires: {report['expires_at']}\") # Available report types: \"aml_summary\", \"kyc_status\", \"transaction_monitoring\", \"risk_assessment\" Compliance Dashboard # Get compliance dashboard data dashboard = client.security.compliance_dashboard_data() print(f\"KYC Statistics:\") print(f\" - Verified users: {dashboard['kyc_stats']['verified_users']}\") print(f\" - Pending verification: {dashboard['kyc_stats']['pending_verification']}\") print(f\" - Rejected applications: {dashboard['kyc_stats']['rejected']}\") print(f\"Transaction Monitoring:\") print(f\" - Transactions monitored: {dashboard['monitoring_stats']['transactions_monitored']}\") print(f\" - Alerts generated: {dashboard['monitoring_stats']['alerts_generated']}\") print(f\" - High-risk transactions: {dashboard['monitoring_stats']['high_risk_transactions']}\") print(f\"Compliance Score: {dashboard['compliance_score']}/100\") Data Export # Export compliance data export_result = client.security.export_compliance_data( format=\"json\", # or \"csv\", \"xml\" date_range={\"start\": \"2024-01-01\", \"end\": \"2024-01-31\"}, data_types=[\"kyc\", \"transactions\", \"audit_logs\"], include_pii=False # Exclude personally identifiable information ) print(f\"Export ID: {export_result['export_id']}\") print(f\"Download URL: {export_result['download_url']}\") print(f\"File size: {export_result['file_size_mb']} MB\") Webhook Management Webhook Configuration # Submit webhook for compliance events webhook_payload = { \"event_type\": \"kyc_status_change\", \"user_id\": \"user_123\", \"old_status\": \"pending\", \"new_status\": \"verified\", \"timestamp\": \"2024-01-15T10:30:00Z\", \"verification_details\": { \"documents_verified\": [\"passport\", \"proof_of_address\"], \"risk_score\": 15 } } webhook_result = client.security.submit_webhook(webhook_payload) print(f\"Webhook submitted: {webhook_result['webhook_id']}\") print(f\"Status: {webhook_result['status']}\") Webhook Analytics # Get webhook statistics webhook_stats = client.security.get_webhook_statistics() print(f\"Total webhooks: {webhook_stats['total_webhooks']}\") print(f\"Successful deliveries: {webhook_stats['successful_deliveries']}\") print(f\"Failed deliveries: {webhook_stats['failed_deliveries']}\") print(f\"Average response time: {webhook_stats['avg_response_time_ms']}ms\") # Retry failed webhooks retry_result = client.security.retry_failed_webhooks(max_retries=3) print(f\"Retried webhooks: {retry_result['retried_count']}\") print(f\"Successful retries: {retry_result['successful_retries']}\") Task Management Asynchronous Task Monitoring # Get status of long-running compliance tasks task_status = client.security.get_task_status(\"task_123\") print(f\"Task ID: {task_status['task_id']}\") print(f\"Status: {task_status['status']}\") print(f\"Progress: {task_status['progress']}%\") print(f\"Started: {task_status['started_at']}\") if task_status['status'] == 'completed': print(f\"Result: {task_status['result']}\") Rate Limiting # Check API rate limit status rate_limit = client.security.get_rate_limit_status() print(f\"Remaining requests: {rate_limit['remaining_requests']}\") print(f\"Reset time: {rate_limit['reset_time']}\") print(f\"Rate limit window: {rate_limit['window_seconds']} seconds\") if rate_limit['remaining_requests'] < 10: print(\"Warning: Approaching rate limit\") Advanced Security Workflows Comprehensive Risk Assessment def perform_risk_assessment(client, address, transaction_history_days=30): \"\"\"Perform comprehensive risk assessment for an address\"\"\" # Start monitoring the address watch_result = client.security.watch_address( address=address, chain=\"ethereum\" ) # Get recent alerts alerts = client.security.get_alerts() address_alerts = [alert for alert in alerts if alert.get('address') == address] # Calculate risk score risk_factors = { \"alert_count\": len(address_alerts), \"high_severity_alerts\": len([a for a in address_alerts if a.get('severity') == 'high']), \"monitoring_duration\": transaction_history_days } # Generate risk assessment report risk_score = min(100, (risk_factors[\"alert_count\"] * 10) + (risk_factors[\"high_severity_alerts\"] * 25)) assessment = { \"address\": address, \"risk_score\": risk_score, \"risk_level\": \"high\" if risk_score > 70 else \"medium\" if risk_score > 30 else \"low\", \"factors\": risk_factors, \"alerts\": address_alerts, \"watch_id\": watch_result.get('watch_id') } return assessment # Usage risk_assessment = perform_risk_assessment( client, \"0x742d35Cc6635C0532925a3b8D\", transaction_history_days=60 ) print(f\"Risk Assessment for {risk_assessment['address']}:\") print(f\"Risk Score: {risk_assessment['risk_score']}/100\") print(f\"Risk Level: {risk_assessment['risk_level'].upper()}\") Automated Compliance Workflow def automated_compliance_check(client, user_id): \"\"\"Automated compliance verification workflow\"\"\" workflow_results = { \"user_id\": user_id, \"kyc_status\": None, \"document_verification\": None, \"risk_assessment\": None, \"compliance_score\": 0 } try: # Step 1: Check KYC status kyc_status = client.security.get_kyc_status() workflow_results[\"kyc_status\"] = kyc_status if kyc_status['status'] == 'not_started': # Initiate KYC if not started kyc_init = client.security.initiate_kyc() workflow_results[\"kyc_initiated\"] = kyc_init # Step 2: Auto-submit KYC if applicable if kyc_status['status'] in ['pending', 'documents_required']: auto_kyc = client.security.auto_submit_kyc() workflow_results[\"auto_kyc\"] = auto_kyc # Step 3: Get audit trail for user audit_trail = client.security.get_audit_trail( user_ids=[user_id], limit=50 ) workflow_results[\"audit_entries\"] = len(audit_trail.get('entries', [])) # Step 4: Calculate compliance score score = 0 if kyc_status['status'] == 'verified': score += 50 if workflow_results[\"audit_entries\"] > 0: score += 20 if kyc_status.get('verification_level') == 'enhanced': score += 30 workflow_results[\"compliance_score\"] = score except Exception as e: workflow_results[\"error\"] = str(e) return workflow_results # Usage compliance_check = automated_compliance_check(client, \"user_123\") print(f\"Compliance Score: {compliance_check['compliance_score']}/100\") Regulatory Reporting Pipeline def generate_regulatory_reports(client, reporting_period): \"\"\"Generate all required regulatory reports for a period\"\"\" report_types = [ \"aml_summary\", \"kyc_status\", \"transaction_monitoring\", \"risk_assessment\" ] generated_reports = [] for report_type in report_types: try: report = client.security.generate_report( start_date=reporting_period[\"start\"], end_date=reporting_period[\"end\"], report_type=report_type ) generated_reports.append({ \"type\": report_type, \"report_id\": report[\"report_id\"], \"status\": report[\"status\"], \"download_url\": report.get(\"download_url\") }) print(f\"Generated {report_type} report: {report['report_id']}\") except Exception as e: print(f\"Failed to generate {report_type} report: {e}\") # Export compliance data try: export = client.security.export_compliance_data( format=\"json\", date_range=reporting_period, data_types=[\"kyc\", \"transactions\", \"audit_logs\"] ) generated_reports.append({ \"type\": \"data_export\", \"export_id\": export[\"export_id\"], \"download_url\": export[\"download_url\"], \"file_size_mb\": export[\"file_size_mb\"] }) except Exception as e: print(f\"Failed to export compliance data: {e}\") return generated_reports # Usage reporting_period = { \"start\": \"2024-01-01\", \"end\": \"2024-01-31\" } reports = generate_regulatory_reports(client, reporting_period) print(f\"Generated {len(reports)} reports and exports\") Error Handling and Best Practices Robust Error Handling def safe_compliance_operation(client, operation, *args, **kwargs): \"\"\"Safely execute compliance operations with proper error handling\"\"\" try: result = getattr(client.security, operation)(*args, **kwargs) return {\"success\": True, \"result\": result} except requests.exceptions.HTTPError as e: error_code = e.response.status_code error_detail = e.response.json().get(\"detail\", str(e)) if error_code == 403: return {\"success\": False, \"error\": \"Insufficient permissions for compliance operation\"} elif error_code == 429: return {\"success\": False, \"error\": \"Rate limit exceeded\", \"retry_after\": e.response.headers.get(\"Retry-After\")} else: return {\"success\": False, \"error\": f\"HTTP {error_code}: {error_detail}\"} except Exception as e: return {\"success\": False, \"error\": f\"Unexpected error: {str(e)}\"} # Usage result = safe_compliance_operation(client, \"get_kyc_status\") if result[\"success\"]: print(f\"KYC Status: {result['result']['status']}\") else: print(f\"Operation failed: {result['error']}\") Compliance Monitoring Best Practices class ComplianceMonitor: \"\"\"Best practices for compliance monitoring\"\"\" def __init__(self, client): self.client = client def setup_monitoring(self, addresses): \"\"\"Setup comprehensive monitoring for multiple addresses\"\"\" watch_ids = [] for address in addresses: try: watch = self.client.security.watch_address( address=address, chain=\"ethereum\" ) watch_ids.append(watch['watch_id']) print(f\"Monitoring setup for {address}: {watch['watch_id']}\") except Exception as e: print(f\"Failed to setup monitoring for {address}: {e}\") return watch_ids def daily_compliance_check(self): \"\"\"Daily compliance status check\"\"\" alerts = self.client.security.get_alerts() high_priority = [a for a in alerts if a.get('severity') == 'high'] if high_priority: print(f\"\u26a0\ufe0f {len(high_priority)} high-priority alerts found!\") for alert in high_priority: print(f\" - {alert['alert_type']}: {alert['description']}\") # Check webhook delivery status webhook_stats = self.client.security.get_webhook_statistics() failure_rate = (webhook_stats['failed_deliveries'] / webhook_stats['total_webhooks']) * 100 if failure_rate > 5: # 5% failure threshold print(f\"\u26a0\ufe0f High webhook failure rate: {failure_rate:.1f}%\") # Retry failed webhooks self.client.security.retry_failed_webhooks() def monthly_audit(self): \"\"\"Monthly compliance audit\"\"\" end_date = datetime.now().strftime(\"%Y-%m-%d\") start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\") # Generate comprehensive audit trail audit = self.client.security.get_audit_trail( start_date=start_date, end_date=end_date, limit=1000 ) # Verify audit integrity integrity = self.client.security.verify_audit_integrity() # Generate compliance reports reports = generate_regulatory_reports(self.client, { \"start\": start_date, \"end\": end_date }) return { \"audit_entries\": len(audit.get('entries', [])), \"integrity_status\": integrity['status'], \"reports_generated\": len(reports) } # Usage monitor = ComplianceMonitor(client) monitor.daily_compliance_check() API Reference SecurityClient Methods Method Description Parameters Returns watch_address() Monitor address for suspicious activity address, chain, provider Dict get_tx_status() Get transaction status and risk assessment tx_hash, provider Dict get_transaction_status() Get transaction confirmation status tx_hash, provider Dict list_watches() List all active address watches - List[Dict] get_alerts() Get security alerts - List[Dict] get_kyc_status() Get KYC verification status - Dict initiate_kyc() Start KYC verification process - Dict auto_submit_kyc() Auto-submit KYC for current user - Dict bulk_auto_submit_kyc() Bulk auto-submit KYC user_ids Dict process_document() Process compliance document document_file, document_type Dict submit_webhook() Submit compliance webhook payload Dict get_webhook_statistics() Get webhook delivery stats - Dict retry_failed_webhooks() Retry failed webhook deliveries max_retries Dict get_audit_trail() Get comprehensive audit trail start_date, end_date, filters Dict verify_audit_integrity() Verify audit trail integrity - Dict generate_report() Generate compliance report start_date, end_date, report_type Dict get_audit_trail_legacy() Get legacy audit trail entity_id, entity_type Dict get_task_status() Get async task status task_id Dict get_rate_limit_status() Get API rate limit status - Dict bulk_document_processing() Process multiple documents documents List[Dict] compliance_dashboard_data() Get compliance dashboard data - Dict export_compliance_data() Export compliance data format, filters Dict Compliance Data Models KYC Status Response { \"status\": \"verified\" | \"pending\" | \"not_started\" | \"rejected\", \"verification_level\": \"basic\" | \"enhanced\", \"required_documents\": [\"passport\", \"proof_of_address\"], \"submission_date\": \"2024-01-15T10:30:00Z\", \"verification_date\": \"2024-01-16T14:20:00Z\" } Security Alert { \"alert_id\": \"alert_123\", \"alert_type\": \"suspicious_transaction\" | \"high_value_transfer\" | \"blacklist_match\", \"severity\": \"low\" | \"medium\" | \"high\" | \"critical\", \"address\": \"0x742d35Cc6635C0532925a3b8D\", \"description\": \"Large transaction to high-risk address\", \"timestamp\": \"2024-01-15T10:30:00Z\", \"risk_score\": 85 }","title":"Security & Compliance"},{"location":"security/#cirtusai-sdk-security-compliance-guide","text":"","title":"CirtusAI SDK Security &amp; Compliance Guide"},{"location":"security/#overview","text":"The CirtusAI SDK provides comprehensive security and compliance features including transaction monitoring, KYC verification, audit trails, compliance reporting, and regulatory adherence tools. The security system integrates with multiple providers and offers enterprise-grade compliance management.","title":"Overview"},{"location":"security/#features","text":"Transaction Monitoring : Real-time blockchain transaction surveillance KYC/AML Compliance : Identity verification and anti-money laundering checks Audit Trails : Comprehensive activity logging and integrity verification Compliance Reporting : Automated regulatory report generation Document Processing : AI-powered compliance document analysis Webhook Management : Real-time compliance event notifications Risk Assessment : Automated risk scoring and alerts","title":"Features"},{"location":"security/#transaction-monitoring","text":"","title":"Transaction Monitoring"},{"location":"security/#address-monitoring","text":"from cirtusai import CirtusAIClient client = CirtusAIClient(\"https://api.cirtusai.com\") client.set_token(\"your_access_token\") # Watch specific address for suspicious activity watch_result = client.security.watch_address( address=\"0x742d35Cc6635C0532925a3b8D\", chain=\"ethereum\", provider=\"blocknative\" ) print(f\"Watch ID: {watch_result['watch_id']}\") print(f\"Status: {watch_result['status']}\") print(f\"Alert threshold: {watch_result['alert_threshold']}\") # List all active watches watches = client.security.list_watches() for watch in watches: print(f\"Watch ID: {watch['watch_id']}\") print(f\"Address: {watch['address']}\") print(f\"Chain: {watch['chain']}\") print(f\"Status: {watch['status']}\")","title":"Address Monitoring"},{"location":"security/#transaction-status-monitoring","text":"# Get transaction status and risk assessment tx_status = client.security.get_tx_status( tx_hash=\"0x1234567890abcdef\", provider=\"blocknative\" ) print(f\"Transaction status: {tx_status['status']}\") print(f\"Risk score: {tx_status['risk_score']}\") print(f\"AML alerts: {tx_status['aml_alerts']}\") # Alternative method status = client.security.get_transaction_status(\"0x1234567890abcdef\") print(f\"Confirmation status: {status}\")","title":"Transaction Status Monitoring"},{"location":"security/#security-alerts","text":"# Get security alerts for monitored addresses alerts = client.security.get_alerts() for alert in alerts: print(f\"Alert ID: {alert['alert_id']}\") print(f\"Type: {alert['alert_type']}\") print(f\"Severity: {alert['severity']}\") print(f\"Address: {alert['address']}\") print(f\"Description: {alert['description']}\") print(f\"Timestamp: {alert['timestamp']}\")","title":"Security Alerts"},{"location":"security/#kycaml-compliance","text":"","title":"KYC/AML Compliance"},{"location":"security/#kyc-status-management","text":"# Check current KYC status kyc_status = client.security.get_kyc_status() print(f\"KYC Status: {kyc_status['status']}\") print(f\"Verification level: {kyc_status['verification_level']}\") print(f\"Required documents: {kyc_status['required_documents']}\") # Initiate KYC process kyc_init = client.security.initiate_kyc() print(f\"KYC session ID: {kyc_init['session_id']}\") print(f\"Upload URL: {kyc_init['upload_url']}\") print(f\"Instructions: {kyc_init['instructions']}\")","title":"KYC Status Management"},{"location":"security/#automated-kyc-processing","text":"# Auto-submit KYC for single user auto_kyc = client.security.auto_submit_kyc() print(f\"Submission status: {auto_kyc['status']}\") print(f\"Processing time: {auto_kyc['estimated_processing_time']}\") # Bulk auto-submit KYC for multiple users user_ids = [\"user_123\", \"user_456\", \"user_789\"] bulk_kyc = client.security.bulk_auto_submit_kyc(user_ids) print(f\"Batch ID: {bulk_kyc['batch_id']}\") print(f\"Submitted: {bulk_kyc['submitted_count']}\") print(f\"Failed: {bulk_kyc['failed_count']}\")","title":"Automated KYC Processing"},{"location":"security/#document-processing","text":"# Process compliance document with open(\"passport.pdf\", \"rb\") as doc_file: document_result = client.security.process_document( document_file=doc_file, document_type=\"passport\" ) print(f\"Document ID: {document_result['document_id']}\") print(f\"Verification status: {document_result['verification_status']}\") print(f\"Extracted data: {document_result['extracted_data']}\") print(f\"Confidence score: {document_result['confidence_score']}\") # Bulk document processing documents = [ {\"file\": \"passport.pdf\", \"type\": \"passport\"}, {\"file\": \"utility_bill.pdf\", \"type\": \"proof_of_address\"}, {\"file\": \"bank_statement.pdf\", \"type\": \"proof_of_income\"} ] bulk_results = client.security.bulk_document_processing(documents) for result in bulk_results: print(f\"Document: {result['document_type']}\") print(f\"Status: {result['verification_status']}\") print(f\"Issues: {result.get('issues', 'None')}\")","title":"Document Processing"},{"location":"security/#audit-trail-management","text":"","title":"Audit Trail Management"},{"location":"security/#comprehensive-audit-logging","text":"# Get detailed audit trail audit_trail = client.security.get_audit_trail( start_date=\"2024-01-01\", end_date=\"2024-01-31\", entity_types=[\"user\", \"transaction\", \"document\"], action_types=[\"create\", \"update\", \"delete\", \"verify\"], user_ids=[\"user_123\"], limit=100 ) print(f\"Total entries: {len(audit_trail['entries'])}\") for entry in audit_trail['entries']: print(f\"Timestamp: {entry['timestamp']}\") print(f\"Action: {entry['action_type']}\") print(f\"Entity: {entry['entity_type']} - {entry['entity_id']}\") print(f\"User: {entry['user_id']}\") print(f\"Details: {entry['details']}\")","title":"Comprehensive Audit Logging"},{"location":"security/#audit-integrity-verification","text":"# Verify audit trail integrity integrity_check = client.security.verify_audit_integrity() print(f\"Integrity status: {integrity_check['status']}\") print(f\"Total entries checked: {integrity_check['entries_checked']}\") print(f\"Hash verification: {integrity_check['hash_verification']}\") print(f\"Timestamp verification: {integrity_check['timestamp_verification']}\") if integrity_check['issues']: print(\"Integrity issues found:\") for issue in integrity_check['issues']: print(f\" - {issue['type']}: {issue['description']}\")","title":"Audit Integrity Verification"},{"location":"security/#legacy-audit-trail-access","text":"# Access legacy audit trail for specific entity legacy_audit = client.security.get_audit_trail_legacy( entity_id=\"transaction_123\", entity_type=\"transaction\" ) print(f\"Entity: {legacy_audit['entity_id']}\") print(f\"Audit entries: {len(legacy_audit['audit_entries'])}\") for entry in legacy_audit['audit_entries']: print(f\" {entry['timestamp']}: {entry['action']} by {entry['user_id']}\")","title":"Legacy Audit Trail Access"},{"location":"security/#compliance-reporting","text":"","title":"Compliance Reporting"},{"location":"security/#automated-report-generation","text":"# Generate compliance report report = client.security.generate_report( start_date=\"2024-01-01\", end_date=\"2024-01-31\", report_type=\"aml_summary\" ) print(f\"Report ID: {report['report_id']}\") print(f\"Status: {report['status']}\") print(f\"Download URL: {report['download_url']}\") print(f\"Expires: {report['expires_at']}\") # Available report types: \"aml_summary\", \"kyc_status\", \"transaction_monitoring\", \"risk_assessment\"","title":"Automated Report Generation"},{"location":"security/#compliance-dashboard","text":"# Get compliance dashboard data dashboard = client.security.compliance_dashboard_data() print(f\"KYC Statistics:\") print(f\" - Verified users: {dashboard['kyc_stats']['verified_users']}\") print(f\" - Pending verification: {dashboard['kyc_stats']['pending_verification']}\") print(f\" - Rejected applications: {dashboard['kyc_stats']['rejected']}\") print(f\"Transaction Monitoring:\") print(f\" - Transactions monitored: {dashboard['monitoring_stats']['transactions_monitored']}\") print(f\" - Alerts generated: {dashboard['monitoring_stats']['alerts_generated']}\") print(f\" - High-risk transactions: {dashboard['monitoring_stats']['high_risk_transactions']}\") print(f\"Compliance Score: {dashboard['compliance_score']}/100\")","title":"Compliance Dashboard"},{"location":"security/#data-export","text":"# Export compliance data export_result = client.security.export_compliance_data( format=\"json\", # or \"csv\", \"xml\" date_range={\"start\": \"2024-01-01\", \"end\": \"2024-01-31\"}, data_types=[\"kyc\", \"transactions\", \"audit_logs\"], include_pii=False # Exclude personally identifiable information ) print(f\"Export ID: {export_result['export_id']}\") print(f\"Download URL: {export_result['download_url']}\") print(f\"File size: {export_result['file_size_mb']} MB\")","title":"Data Export"},{"location":"security/#webhook-management","text":"","title":"Webhook Management"},{"location":"security/#webhook-configuration","text":"# Submit webhook for compliance events webhook_payload = { \"event_type\": \"kyc_status_change\", \"user_id\": \"user_123\", \"old_status\": \"pending\", \"new_status\": \"verified\", \"timestamp\": \"2024-01-15T10:30:00Z\", \"verification_details\": { \"documents_verified\": [\"passport\", \"proof_of_address\"], \"risk_score\": 15 } } webhook_result = client.security.submit_webhook(webhook_payload) print(f\"Webhook submitted: {webhook_result['webhook_id']}\") print(f\"Status: {webhook_result['status']}\")","title":"Webhook Configuration"},{"location":"security/#webhook-analytics","text":"# Get webhook statistics webhook_stats = client.security.get_webhook_statistics() print(f\"Total webhooks: {webhook_stats['total_webhooks']}\") print(f\"Successful deliveries: {webhook_stats['successful_deliveries']}\") print(f\"Failed deliveries: {webhook_stats['failed_deliveries']}\") print(f\"Average response time: {webhook_stats['avg_response_time_ms']}ms\") # Retry failed webhooks retry_result = client.security.retry_failed_webhooks(max_retries=3) print(f\"Retried webhooks: {retry_result['retried_count']}\") print(f\"Successful retries: {retry_result['successful_retries']}\")","title":"Webhook Analytics"},{"location":"security/#task-management","text":"","title":"Task Management"},{"location":"security/#asynchronous-task-monitoring","text":"# Get status of long-running compliance tasks task_status = client.security.get_task_status(\"task_123\") print(f\"Task ID: {task_status['task_id']}\") print(f\"Status: {task_status['status']}\") print(f\"Progress: {task_status['progress']}%\") print(f\"Started: {task_status['started_at']}\") if task_status['status'] == 'completed': print(f\"Result: {task_status['result']}\")","title":"Asynchronous Task Monitoring"},{"location":"security/#rate-limiting","text":"# Check API rate limit status rate_limit = client.security.get_rate_limit_status() print(f\"Remaining requests: {rate_limit['remaining_requests']}\") print(f\"Reset time: {rate_limit['reset_time']}\") print(f\"Rate limit window: {rate_limit['window_seconds']} seconds\") if rate_limit['remaining_requests'] < 10: print(\"Warning: Approaching rate limit\")","title":"Rate Limiting"},{"location":"security/#advanced-security-workflows","text":"","title":"Advanced Security Workflows"},{"location":"security/#comprehensive-risk-assessment","text":"def perform_risk_assessment(client, address, transaction_history_days=30): \"\"\"Perform comprehensive risk assessment for an address\"\"\" # Start monitoring the address watch_result = client.security.watch_address( address=address, chain=\"ethereum\" ) # Get recent alerts alerts = client.security.get_alerts() address_alerts = [alert for alert in alerts if alert.get('address') == address] # Calculate risk score risk_factors = { \"alert_count\": len(address_alerts), \"high_severity_alerts\": len([a for a in address_alerts if a.get('severity') == 'high']), \"monitoring_duration\": transaction_history_days } # Generate risk assessment report risk_score = min(100, (risk_factors[\"alert_count\"] * 10) + (risk_factors[\"high_severity_alerts\"] * 25)) assessment = { \"address\": address, \"risk_score\": risk_score, \"risk_level\": \"high\" if risk_score > 70 else \"medium\" if risk_score > 30 else \"low\", \"factors\": risk_factors, \"alerts\": address_alerts, \"watch_id\": watch_result.get('watch_id') } return assessment # Usage risk_assessment = perform_risk_assessment( client, \"0x742d35Cc6635C0532925a3b8D\", transaction_history_days=60 ) print(f\"Risk Assessment for {risk_assessment['address']}:\") print(f\"Risk Score: {risk_assessment['risk_score']}/100\") print(f\"Risk Level: {risk_assessment['risk_level'].upper()}\")","title":"Comprehensive Risk Assessment"},{"location":"security/#automated-compliance-workflow","text":"def automated_compliance_check(client, user_id): \"\"\"Automated compliance verification workflow\"\"\" workflow_results = { \"user_id\": user_id, \"kyc_status\": None, \"document_verification\": None, \"risk_assessment\": None, \"compliance_score\": 0 } try: # Step 1: Check KYC status kyc_status = client.security.get_kyc_status() workflow_results[\"kyc_status\"] = kyc_status if kyc_status['status'] == 'not_started': # Initiate KYC if not started kyc_init = client.security.initiate_kyc() workflow_results[\"kyc_initiated\"] = kyc_init # Step 2: Auto-submit KYC if applicable if kyc_status['status'] in ['pending', 'documents_required']: auto_kyc = client.security.auto_submit_kyc() workflow_results[\"auto_kyc\"] = auto_kyc # Step 3: Get audit trail for user audit_trail = client.security.get_audit_trail( user_ids=[user_id], limit=50 ) workflow_results[\"audit_entries\"] = len(audit_trail.get('entries', [])) # Step 4: Calculate compliance score score = 0 if kyc_status['status'] == 'verified': score += 50 if workflow_results[\"audit_entries\"] > 0: score += 20 if kyc_status.get('verification_level') == 'enhanced': score += 30 workflow_results[\"compliance_score\"] = score except Exception as e: workflow_results[\"error\"] = str(e) return workflow_results # Usage compliance_check = automated_compliance_check(client, \"user_123\") print(f\"Compliance Score: {compliance_check['compliance_score']}/100\")","title":"Automated Compliance Workflow"},{"location":"security/#regulatory-reporting-pipeline","text":"def generate_regulatory_reports(client, reporting_period): \"\"\"Generate all required regulatory reports for a period\"\"\" report_types = [ \"aml_summary\", \"kyc_status\", \"transaction_monitoring\", \"risk_assessment\" ] generated_reports = [] for report_type in report_types: try: report = client.security.generate_report( start_date=reporting_period[\"start\"], end_date=reporting_period[\"end\"], report_type=report_type ) generated_reports.append({ \"type\": report_type, \"report_id\": report[\"report_id\"], \"status\": report[\"status\"], \"download_url\": report.get(\"download_url\") }) print(f\"Generated {report_type} report: {report['report_id']}\") except Exception as e: print(f\"Failed to generate {report_type} report: {e}\") # Export compliance data try: export = client.security.export_compliance_data( format=\"json\", date_range=reporting_period, data_types=[\"kyc\", \"transactions\", \"audit_logs\"] ) generated_reports.append({ \"type\": \"data_export\", \"export_id\": export[\"export_id\"], \"download_url\": export[\"download_url\"], \"file_size_mb\": export[\"file_size_mb\"] }) except Exception as e: print(f\"Failed to export compliance data: {e}\") return generated_reports # Usage reporting_period = { \"start\": \"2024-01-01\", \"end\": \"2024-01-31\" } reports = generate_regulatory_reports(client, reporting_period) print(f\"Generated {len(reports)} reports and exports\")","title":"Regulatory Reporting Pipeline"},{"location":"security/#error-handling-and-best-practices","text":"","title":"Error Handling and Best Practices"},{"location":"security/#robust-error-handling","text":"def safe_compliance_operation(client, operation, *args, **kwargs): \"\"\"Safely execute compliance operations with proper error handling\"\"\" try: result = getattr(client.security, operation)(*args, **kwargs) return {\"success\": True, \"result\": result} except requests.exceptions.HTTPError as e: error_code = e.response.status_code error_detail = e.response.json().get(\"detail\", str(e)) if error_code == 403: return {\"success\": False, \"error\": \"Insufficient permissions for compliance operation\"} elif error_code == 429: return {\"success\": False, \"error\": \"Rate limit exceeded\", \"retry_after\": e.response.headers.get(\"Retry-After\")} else: return {\"success\": False, \"error\": f\"HTTP {error_code}: {error_detail}\"} except Exception as e: return {\"success\": False, \"error\": f\"Unexpected error: {str(e)}\"} # Usage result = safe_compliance_operation(client, \"get_kyc_status\") if result[\"success\"]: print(f\"KYC Status: {result['result']['status']}\") else: print(f\"Operation failed: {result['error']}\")","title":"Robust Error Handling"},{"location":"security/#compliance-monitoring-best-practices","text":"class ComplianceMonitor: \"\"\"Best practices for compliance monitoring\"\"\" def __init__(self, client): self.client = client def setup_monitoring(self, addresses): \"\"\"Setup comprehensive monitoring for multiple addresses\"\"\" watch_ids = [] for address in addresses: try: watch = self.client.security.watch_address( address=address, chain=\"ethereum\" ) watch_ids.append(watch['watch_id']) print(f\"Monitoring setup for {address}: {watch['watch_id']}\") except Exception as e: print(f\"Failed to setup monitoring for {address}: {e}\") return watch_ids def daily_compliance_check(self): \"\"\"Daily compliance status check\"\"\" alerts = self.client.security.get_alerts() high_priority = [a for a in alerts if a.get('severity') == 'high'] if high_priority: print(f\"\u26a0\ufe0f {len(high_priority)} high-priority alerts found!\") for alert in high_priority: print(f\" - {alert['alert_type']}: {alert['description']}\") # Check webhook delivery status webhook_stats = self.client.security.get_webhook_statistics() failure_rate = (webhook_stats['failed_deliveries'] / webhook_stats['total_webhooks']) * 100 if failure_rate > 5: # 5% failure threshold print(f\"\u26a0\ufe0f High webhook failure rate: {failure_rate:.1f}%\") # Retry failed webhooks self.client.security.retry_failed_webhooks() def monthly_audit(self): \"\"\"Monthly compliance audit\"\"\" end_date = datetime.now().strftime(\"%Y-%m-%d\") start_date = (datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\") # Generate comprehensive audit trail audit = self.client.security.get_audit_trail( start_date=start_date, end_date=end_date, limit=1000 ) # Verify audit integrity integrity = self.client.security.verify_audit_integrity() # Generate compliance reports reports = generate_regulatory_reports(self.client, { \"start\": start_date, \"end\": end_date }) return { \"audit_entries\": len(audit.get('entries', [])), \"integrity_status\": integrity['status'], \"reports_generated\": len(reports) } # Usage monitor = ComplianceMonitor(client) monitor.daily_compliance_check()","title":"Compliance Monitoring Best Practices"},{"location":"security/#api-reference","text":"","title":"API Reference"},{"location":"security/#securityclient-methods","text":"Method Description Parameters Returns watch_address() Monitor address for suspicious activity address, chain, provider Dict get_tx_status() Get transaction status and risk assessment tx_hash, provider Dict get_transaction_status() Get transaction confirmation status tx_hash, provider Dict list_watches() List all active address watches - List[Dict] get_alerts() Get security alerts - List[Dict] get_kyc_status() Get KYC verification status - Dict initiate_kyc() Start KYC verification process - Dict auto_submit_kyc() Auto-submit KYC for current user - Dict bulk_auto_submit_kyc() Bulk auto-submit KYC user_ids Dict process_document() Process compliance document document_file, document_type Dict submit_webhook() Submit compliance webhook payload Dict get_webhook_statistics() Get webhook delivery stats - Dict retry_failed_webhooks() Retry failed webhook deliveries max_retries Dict get_audit_trail() Get comprehensive audit trail start_date, end_date, filters Dict verify_audit_integrity() Verify audit trail integrity - Dict generate_report() Generate compliance report start_date, end_date, report_type Dict get_audit_trail_legacy() Get legacy audit trail entity_id, entity_type Dict get_task_status() Get async task status task_id Dict get_rate_limit_status() Get API rate limit status - Dict bulk_document_processing() Process multiple documents documents List[Dict] compliance_dashboard_data() Get compliance dashboard data - Dict export_compliance_data() Export compliance data format, filters Dict","title":"SecurityClient Methods"},{"location":"security/#compliance-data-models","text":"","title":"Compliance Data Models"},{"location":"security/#kyc-status-response","text":"{ \"status\": \"verified\" | \"pending\" | \"not_started\" | \"rejected\", \"verification_level\": \"basic\" | \"enhanced\", \"required_documents\": [\"passport\", \"proof_of_address\"], \"submission_date\": \"2024-01-15T10:30:00Z\", \"verification_date\": \"2024-01-16T14:20:00Z\" }","title":"KYC Status Response"},{"location":"security/#security-alert","text":"{ \"alert_id\": \"alert_123\", \"alert_type\": \"suspicious_transaction\" | \"high_value_transfer\" | \"blacklist_match\", \"severity\": \"low\" | \"medium\" | \"high\" | \"critical\", \"address\": \"0x742d35Cc6635C0532925a3b8D\", \"description\": \"Large transaction to high-risk address\", \"timestamp\": \"2024-01-15T10:30:00Z\", \"risk_score\": 85 }","title":"Security Alert"},{"location":"wallets/","text":"CirtusAI SDK Wallet Management Guide Overview The CirtusAI SDK provides comprehensive wallet management capabilities including crypto wallet operations, asset management, email integration, RWA (Real World Assets) support, DeFi yield strategies, and advanced features like gas sponsorship and agent wallets. Features Multi-Chain Wallet Support : Create and manage wallets across multiple blockchains Asset Management : Track and manage crypto assets and email accounts Transaction Management : Send transactions, check balances, and monitor activity Gas Sponsorship : Sponsor gas fees for improved user experience Onramp Integration : Fiat-to-crypto conversion support RWA Asset Registry : Register and manage real-world assets DeFi Yield Strategies : Automated yield farming and strategy execution Event Subscriptions : Real-time blockchain event monitoring Agent Wallets : Smart contract wallets with programmable controls Account Abstraction : ERC-4337 user operations support Basic Wallet Operations Create and Manage Wallets from cirtusai import CirtusAIClient client = CirtusAIClient(\"https://api.cirtusai.com\") client.set_token(\"your_access_token\") # Create a new wallet wallet = client.wallets.create_wallet(chain=\"ethereum\") print(f\"New wallet address: {wallet['address']}\") print(f\"Chain: {wallet['chain']}\") # Import existing wallet imported_wallet = client.wallets.import_wallet( chain=\"ethereum\", private_key=\"your_private_key_hex\" ) # List all wallets wallets = client.wallets.list_wallets() for wallet in wallets: print(f\"Wallet ID: {wallet['id']}\") print(f\"Address: {wallet['address']}\") print(f\"Chain: {wallet['chain']}\") # Delete wallet client.wallets.delete_wallet(\"wallet_id\") Asset Management # List all assets assets = client.wallets.list_assets() print(f\"Total assets: {len(assets)}\") # Add individual asset client.wallets.add_asset( asset_key=\"BTC_ADDRESS\", asset_value=\"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa\" ) # Bulk add assets assets_dict = { \"ETH_ADDRESS\": \"0x742d35Cc6635C0532925a3b8D\", \"USDC_ADDRESS\": \"0xA0b86a33E6c3b\", \"API_KEY\": \"your_api_key_here\" } client.wallets.bulk_add_assets(assets_dict) # Add crypto wallet to assets crypto_asset = client.wallets.add_crypto(chain=\"ethereum\") print(f\"Crypto wallet added: {crypto_asset}\") Transaction Operations Token Operations # Get token balance balance = client.wallets.get_token_balance( wallet_id=\"wallet_123\", token_address=\"0xA0b86a33E6c3b\" # USDC ) print(f\"Token balance: {balance}\") # Transfer tokens transfer_result = client.wallets.transfer_tokens( wallet_id=\"wallet_123\", token_address=\"0xA0b86a33E6c3b\", to_address=\"0x742d35Cc6635C0532925a3b8D\", amount=100.0 ) print(f\"Transfer hash: {transfer_result['transaction_hash']}\") # Approve token spending approval_result = client.wallets.approve_tokens( wallet_id=\"wallet_123\", token_address=\"0xA0b86a33E6c3b\", spender_address=\"0x1234567890123456789012345678901234567890\", amount=1000.0 ) Native Currency Operations # Get native balance (ETH, MATIC, etc.) balance = client.wallets.get_balance( chain=\"ethereum\", address=\"0x742d35Cc6635C0532925a3b8D\" ) print(f\"ETH balance: {balance}\") # Send raw transaction tx_hash = client.wallets.send_transaction( chain=\"ethereum\", to=\"0x742d35Cc6635C0532925a3b8D\", signed_tx=\"0x1234567890abcdef\" # Pre-signed transaction ) print(f\"Transaction hash: {tx_hash}\") Gas Management Gas Sponsorship # Sponsor gas for token transactions sponsorship_hash = client.wallets.sponsor_gas( token_address=\"0xA0b86a33E6c3b\", amount=Decimal(\"100.0\") ) print(f\"Gas sponsorship transaction: {sponsorship_hash}\") # Check gas sponsorship balance sponsorship_balance = client.wallets.get_gas_sponsorship_balance() print(f\"Available gas sponsorship: {sponsorship_balance}\") Fiat Onramp Integration Create Onramp Session # Create fiat-to-crypto onramp session onramp_session = client.wallets.create_onramp_session( currency=\"USD\", amount=500.0 ) print(f\"Session ID: {onramp_session['session_id']}\") print(f\"Payment URL: {onramp_session['payment_url']}\") print(f\"Status: {onramp_session['status']}\") # Check onramp status status = client.wallets.get_onramp_status(onramp_session['session_id']) print(f\"Onramp status: {status['status']}\") print(f\"Amount received: {status.get('amount_received', 0)}\") Real World Assets (RWA) RWA Asset Management # Register RWA asset rwa_asset = client.wallets.register_rwa_asset( token_address=\"0x1234567890123456789012345678901234567890\", token_id=\"123\", metadata_uri=\"https://metadata.example.com/asset/123\" ) print(f\"RWA Asset registered: {rwa_asset['asset_id']}\") print(f\"Status: {rwa_asset['status']}\") # List all RWA assets rwa_assets = client.wallets.list_rwa_assets() for asset in rwa_assets: print(f\"Asset ID: {asset['asset_id']}\") print(f\"Token Address: {asset['token_address']}\") print(f\"Token ID: {asset['token_id']}\") # Transfer RWA asset transfer_hash = client.wallets.transfer_rwa_asset( asset_id=\"rwa_asset_123\", to_address=\"0x742d35Cc6635C0532925a3b8D\" ) print(f\"RWA transfer hash: {transfer_hash}\") DeFi Yield Strategies Yield Strategy Management # Create yield strategy strategy = client.wallets.create_yield_strategy( asset_key=\"USDC_BALANCE\", protocol=\"aave\", min_apr=Decimal(\"5.0\") # 5% minimum APR ) print(f\"Strategy ID: {strategy['strategy_id']}\") print(f\"Protocol: {strategy['protocol']}\") print(f\"Target APR: {strategy['target_apr']}\") # List all yield strategies strategies = client.wallets.list_yield_strategies() for strategy in strategies: print(f\"Strategy: {strategy['strategy_id']}\") print(f\"Asset: {strategy['asset_key']}\") print(f\"Current APR: {strategy['current_apr']}\") # Execute yield strategy execution_result = client.wallets.run_yield_strategy(\"strategy_123\") print(f\"Execution status: {execution_result['status']}\") print(f\"Amount deployed: {execution_result['amount_deployed']}\") Event Monitoring Blockchain Event Subscriptions # Subscribe to blockchain events subscription_id = client.wallets.subscribe_event( chain=\"ethereum\", filter_criteria={ \"address\": \"0x1234567890123456789012345678901234567890\", \"topics\": [\"Transfer(address,address,uint256)\"] }, callback_url=\"https://your-webhook.com/events\" ) print(f\"Subscription ID: {subscription_id}\") # List active subscriptions subscriptions = client.wallets.list_event_subscriptions() for sub in subscriptions: print(f\"Subscription: {sub['subscription_id']}\") print(f\"Chain: {sub['chain']}\") print(f\"Status: {sub['status']}\") # Unsubscribe from events client.wallets.unsubscribe_event(subscription_id) Agent Wallets (Smart Contract Wallets) Deploy and Manage Agent Wallets # Deploy new agent wallet agent_wallet = client.wallets.deploy_agent_wallet() print(f\"Agent wallet address: {agent_wallet['address']}\") print(f\"Deployment hash: {agent_wallet['deployment_hash']}\") # List all agent wallets agent_wallets = client.wallets.list_agent_wallets() for wallet in agent_wallets: print(f\"Address: {wallet['address']}\") print(f\"Owner: {wallet['owner']}\") print(f\"Threshold: {wallet['threshold']}\") # Get specific agent wallet details wallet_details = client.wallets.get_agent_wallet(\"0x1234567890123456789012345678901234567890\") print(f\"Spending limits: {wallet_details['spending_limits']}\") print(f\"Whitelist: {wallet_details['whitelist']}\") Agent Wallet Configuration # Set spending limits limit_hash = client.wallets.set_spending_limit( address=\"0x1234567890123456789012345678901234567890\", token=\"0xA0b86a33E6c3b\", # USDC amount=1000, # 1000 USDC period=86400 # 24 hours ) # Update whitelist whitelist_hash = client.wallets.update_whitelist( address=\"0x1234567890123456789012345678901234567890\", target=\"0x742d35Cc6635C0532925a3b8D\", allowed=True ) # Set multi-sig threshold threshold_hash = client.wallets.set_threshold( address=\"0x1234567890123456789012345678901234567890\", new_threshold=2 # Require 2 signatures ) Agent Wallet Transactions # List wallet transactions transactions = client.wallets.list_wallet_transactions( address=\"0x1234567890123456789012345678901234567890\" ) for tx in transactions: print(f\"Hash: {tx['hash']}\") print(f\"To: {tx['to']}\") print(f\"Value: {tx['value']}\") print(f\"Status: {tx['status']}\") Account Abstraction (ERC-4337) User Operations # Send user operation user_op = { \"sender\": \"0x1234567890123456789012345678901234567890\", \"nonce\": \"0x1\", \"initCode\": \"0x\", \"callData\": \"0xa9059cbb000000000000000000000000742d35cc6635c0532925a3b8d00000000000000000000000000000000000000000000000000000000000000064\", \"callGasLimit\": \"0x5208\", \"verificationGasLimit\": \"0x186a0\", \"preVerificationGas\": \"0x5208\", \"maxFeePerGas\": \"0x77359400\", \"maxPriorityFeePerGas\": \"0x77359400\", \"paymasterAndData\": \"0x\", \"signature\": \"0x...\" } result = client.wallets.send_user_operation( user_op=user_op, entry_point_address=\"0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789\" ) print(f\"User operation hash: {result['userOpHash']}\") # Check user operation status status = client.wallets.get_user_operation_status(result['userOpHash']) print(f\"Status: {status['status']}\") print(f\"Transaction hash: {status.get('transactionHash')}\") Email Integration Email Account Management # List email accounts email_accounts = client.wallets.list_email_accounts() for account in email_accounts: print(f\"Account ID: {account['id']}\") print(f\"Email: {account['email_address']}\") print(f\"Provider: {account['provider']}\") # Create email account email_account = client.wallets.create_email_account( provider=\"gmail\", email_address=\"user@gmail.com\", config={ \"refresh_token\": \"your_refresh_token\", \"client_id\": \"your_client_id\", \"client_secret\": \"your_client_secret\" } ) # Get specific email account account = client.wallets.get_email_account(\"account_123\") print(f\"Email: {account['email_address']}\") print(f\"Status: {account['status']}\") # Update email account updated_account = client.wallets.update_email_account( account_id=\"account_123\", provider=\"gmail\", email_address=\"updated@gmail.com\", config={\"refresh_token\": \"new_refresh_token\"} ) # Refresh email token refreshed = client.wallets.refresh_email_token(\"account_123\") print(f\"Token refreshed: {refreshed['success']}\") # Delete email account client.wallets.delete_email_account(\"account_123\") Advanced Wallet Workflows Multi-Chain Portfolio Management def manage_multi_chain_portfolio(client): \"\"\"Manage assets across multiple chains\"\"\" # Create wallets on different chains chains = [\"ethereum\", \"polygon\", \"arbitrum\"] wallets = {} for chain in chains: wallet = client.wallets.create_wallet(chain=chain) wallets[chain] = wallet print(f\"Created {chain} wallet: {wallet['address']}\") # Check balances across all chains portfolio = {} for chain, wallet in wallets.items(): try: balance = client.wallets.get_balance(chain, wallet['address']) portfolio[chain] = balance except Exception as e: print(f\"Error getting {chain} balance: {e}\") portfolio[chain] = 0 return portfolio # Usage portfolio = manage_multi_chain_portfolio(client) print(f\"Portfolio balances: {portfolio}\") Automated Yield Farming def setup_yield_farming(client, asset_allocation): \"\"\"Setup automated yield farming across protocols\"\"\" strategies = [] for asset, config in asset_allocation.items(): try: strategy = client.wallets.create_yield_strategy( asset_key=asset, protocol=config[\"protocol\"], min_apr=config[\"min_apr\"] ) strategies.append(strategy) # Execute strategy immediately if configured if config.get(\"auto_execute\", False): result = client.wallets.run_yield_strategy(strategy['strategy_id']) print(f\"Executed strategy {strategy['strategy_id']}: {result['status']}\") except Exception as e: print(f\"Failed to create strategy for {asset}: {e}\") return strategies # Usage allocation = { \"USDC_BALANCE\": { \"protocol\": \"aave\", \"min_apr\": Decimal(\"4.0\"), \"auto_execute\": True }, \"ETH_BALANCE\": { \"protocol\": \"compound\", \"min_apr\": Decimal(\"3.5\"), \"auto_execute\": False } } strategies = setup_yield_farming(client, allocation) Smart Contract Interaction def deploy_and_configure_agent_wallet(client, config): \"\"\"Deploy and fully configure an agent wallet\"\"\" # Deploy agent wallet wallet = client.wallets.deploy_agent_wallet() address = wallet['address'] print(f\"Deployed agent wallet: {address}\") # Configure spending limits for token, limit_config in config['spending_limits'].items(): client.wallets.set_spending_limit( address=address, token=token, amount=limit_config['amount'], period=limit_config['period'] ) # Setup whitelist for target in config['whitelist']: client.wallets.update_whitelist( address=address, target=target, allowed=True ) # Set multi-sig threshold if config.get('threshold'): client.wallets.set_threshold(address, config['threshold']) return wallet # Usage wallet_config = { \"spending_limits\": { \"0xA0b86a33E6c3b\": {\"amount\": 1000, \"period\": 86400}, # USDC daily limit \"0x0000000000000000000000000000000000000000\": {\"amount\": 1, \"period\": 86400} # ETH daily limit }, \"whitelist\": [ \"0x742d35Cc6635C0532925a3b8D\", \"0x1234567890123456789012345678901234567890\" ], \"threshold\": 2 } agent_wallet = deploy_and_configure_agent_wallet(client, wallet_config) Error Handling and Best Practices Transaction Safety def safe_token_transfer(client, wallet_id, token_address, to_address, amount): \"\"\"Safely execute token transfer with checks\"\"\" try: # Check balance first balance = client.wallets.get_token_balance(wallet_id, token_address) if balance['balance'] < amount: return {\"success\": False, \"error\": \"Insufficient balance\"} # Execute transfer result = client.wallets.transfer_tokens( wallet_id=wallet_id, token_address=token_address, to_address=to_address, amount=amount ) return {\"success\": True, \"transaction_hash\": result['transaction_hash']} except Exception as e: return {\"success\": False, \"error\": str(e)} # Usage result = safe_token_transfer( client, \"wallet_123\", \"0xA0b86a33E6c3b\", \"0x742d35Cc6635C0532925a3b8D\", 100.0 ) if result[\"success\"]: print(f\"Transfer successful: {result['transaction_hash']}\") else: print(f\"Transfer failed: {result['error']}\") Gas Optimization def optimize_gas_usage(client, operations): \"\"\"Optimize gas usage for multiple operations\"\"\" # Check gas sponsorship balance sponsorship_balance = client.wallets.get_gas_sponsorship_balance() if sponsorship_balance > 0: print(f\"Using gas sponsorship: {sponsorship_balance} available\") # Execute operations using sponsored gas for op in operations: try: if op['type'] == 'transfer': result = client.wallets.transfer_tokens(**op['params']) print(f\"Sponsored transfer: {result['transaction_hash']}\") except Exception as e: print(f\"Operation failed: {e}\") else: print(\"No gas sponsorship available, using regular gas\") # Execute operations normally # Usage operations = [ { \"type\": \"transfer\", \"params\": { \"wallet_id\": \"wallet_123\", \"token_address\": \"0xA0b86a33E6c3b\", \"to_address\": \"0x742d35Cc6635C0532925a3b8D\", \"amount\": 50.0 } } ] optimize_gas_usage(client, operations) API Reference WalletsClient Methods Method Description Parameters Returns create_wallet() Create new wallet chain Dict import_wallet() Import existing wallet chain, private_key Dict list_wallets() List all wallets - List[Dict] delete_wallet() Delete wallet wallet_id None get_token_balance() Get token balance wallet_id, token_address Dict transfer_tokens() Transfer tokens wallet_id, token_address, to_address, amount Dict approve_tokens() Approve token spending wallet_id, token_address, spender_address, amount Dict get_balance() Get native currency balance chain, address Decimal send_transaction() Send raw transaction chain, to, signed_tx str sponsor_gas() Sponsor gas fees token_address, amount str get_gas_sponsorship_balance() Get sponsorship balance - Decimal create_onramp_session() Create fiat onramp currency, amount Dict get_onramp_status() Check onramp status session_id Dict register_rwa_asset() Register RWA asset token_address, token_id, metadata_uri Dict list_rwa_assets() List RWA assets - List[Dict] transfer_rwa_asset() Transfer RWA asset asset_id, to_address str create_yield_strategy() Create yield strategy asset_key, protocol, min_apr Dict list_yield_strategies() List yield strategies - List[Dict] run_yield_strategy() Execute yield strategy strategy_id Dict subscribe_event() Subscribe to events chain, filter_criteria, callback_url str list_event_subscriptions() List subscriptions - List[Dict] unsubscribe_event() Unsubscribe from events subscription_id None deploy_agent_wallet() Deploy agent wallet - Dict list_agent_wallets() List agent wallets - List[Dict] get_agent_wallet() Get agent wallet details address Dict set_spending_limit() Set spending limit address, token, amount, period str update_whitelist() Update whitelist address, target, allowed str set_threshold() Set multi-sig threshold address, new_threshold str list_wallet_transactions() List wallet transactions address List[Dict] send_user_operation() Send user operation user_op, entry_point_address Dict get_user_operation_status() Get user op status user_op_hash Dict","title":"Wallet Operations"},{"location":"wallets/#cirtusai-sdk-wallet-management-guide","text":"","title":"CirtusAI SDK Wallet Management Guide"},{"location":"wallets/#overview","text":"The CirtusAI SDK provides comprehensive wallet management capabilities including crypto wallet operations, asset management, email integration, RWA (Real World Assets) support, DeFi yield strategies, and advanced features like gas sponsorship and agent wallets.","title":"Overview"},{"location":"wallets/#features","text":"Multi-Chain Wallet Support : Create and manage wallets across multiple blockchains Asset Management : Track and manage crypto assets and email accounts Transaction Management : Send transactions, check balances, and monitor activity Gas Sponsorship : Sponsor gas fees for improved user experience Onramp Integration : Fiat-to-crypto conversion support RWA Asset Registry : Register and manage real-world assets DeFi Yield Strategies : Automated yield farming and strategy execution Event Subscriptions : Real-time blockchain event monitoring Agent Wallets : Smart contract wallets with programmable controls Account Abstraction : ERC-4337 user operations support","title":"Features"},{"location":"wallets/#basic-wallet-operations","text":"","title":"Basic Wallet Operations"},{"location":"wallets/#create-and-manage-wallets","text":"from cirtusai import CirtusAIClient client = CirtusAIClient(\"https://api.cirtusai.com\") client.set_token(\"your_access_token\") # Create a new wallet wallet = client.wallets.create_wallet(chain=\"ethereum\") print(f\"New wallet address: {wallet['address']}\") print(f\"Chain: {wallet['chain']}\") # Import existing wallet imported_wallet = client.wallets.import_wallet( chain=\"ethereum\", private_key=\"your_private_key_hex\" ) # List all wallets wallets = client.wallets.list_wallets() for wallet in wallets: print(f\"Wallet ID: {wallet['id']}\") print(f\"Address: {wallet['address']}\") print(f\"Chain: {wallet['chain']}\") # Delete wallet client.wallets.delete_wallet(\"wallet_id\")","title":"Create and Manage Wallets"},{"location":"wallets/#asset-management","text":"# List all assets assets = client.wallets.list_assets() print(f\"Total assets: {len(assets)}\") # Add individual asset client.wallets.add_asset( asset_key=\"BTC_ADDRESS\", asset_value=\"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa\" ) # Bulk add assets assets_dict = { \"ETH_ADDRESS\": \"0x742d35Cc6635C0532925a3b8D\", \"USDC_ADDRESS\": \"0xA0b86a33E6c3b\", \"API_KEY\": \"your_api_key_here\" } client.wallets.bulk_add_assets(assets_dict) # Add crypto wallet to assets crypto_asset = client.wallets.add_crypto(chain=\"ethereum\") print(f\"Crypto wallet added: {crypto_asset}\")","title":"Asset Management"},{"location":"wallets/#transaction-operations","text":"","title":"Transaction Operations"},{"location":"wallets/#token-operations","text":"# Get token balance balance = client.wallets.get_token_balance( wallet_id=\"wallet_123\", token_address=\"0xA0b86a33E6c3b\" # USDC ) print(f\"Token balance: {balance}\") # Transfer tokens transfer_result = client.wallets.transfer_tokens( wallet_id=\"wallet_123\", token_address=\"0xA0b86a33E6c3b\", to_address=\"0x742d35Cc6635C0532925a3b8D\", amount=100.0 ) print(f\"Transfer hash: {transfer_result['transaction_hash']}\") # Approve token spending approval_result = client.wallets.approve_tokens( wallet_id=\"wallet_123\", token_address=\"0xA0b86a33E6c3b\", spender_address=\"0x1234567890123456789012345678901234567890\", amount=1000.0 )","title":"Token Operations"},{"location":"wallets/#native-currency-operations","text":"# Get native balance (ETH, MATIC, etc.) balance = client.wallets.get_balance( chain=\"ethereum\", address=\"0x742d35Cc6635C0532925a3b8D\" ) print(f\"ETH balance: {balance}\") # Send raw transaction tx_hash = client.wallets.send_transaction( chain=\"ethereum\", to=\"0x742d35Cc6635C0532925a3b8D\", signed_tx=\"0x1234567890abcdef\" # Pre-signed transaction ) print(f\"Transaction hash: {tx_hash}\")","title":"Native Currency Operations"},{"location":"wallets/#gas-management","text":"","title":"Gas Management"},{"location":"wallets/#gas-sponsorship","text":"# Sponsor gas for token transactions sponsorship_hash = client.wallets.sponsor_gas( token_address=\"0xA0b86a33E6c3b\", amount=Decimal(\"100.0\") ) print(f\"Gas sponsorship transaction: {sponsorship_hash}\") # Check gas sponsorship balance sponsorship_balance = client.wallets.get_gas_sponsorship_balance() print(f\"Available gas sponsorship: {sponsorship_balance}\")","title":"Gas Sponsorship"},{"location":"wallets/#fiat-onramp-integration","text":"","title":"Fiat Onramp Integration"},{"location":"wallets/#create-onramp-session","text":"# Create fiat-to-crypto onramp session onramp_session = client.wallets.create_onramp_session( currency=\"USD\", amount=500.0 ) print(f\"Session ID: {onramp_session['session_id']}\") print(f\"Payment URL: {onramp_session['payment_url']}\") print(f\"Status: {onramp_session['status']}\") # Check onramp status status = client.wallets.get_onramp_status(onramp_session['session_id']) print(f\"Onramp status: {status['status']}\") print(f\"Amount received: {status.get('amount_received', 0)}\")","title":"Create Onramp Session"},{"location":"wallets/#real-world-assets-rwa","text":"","title":"Real World Assets (RWA)"},{"location":"wallets/#rwa-asset-management","text":"# Register RWA asset rwa_asset = client.wallets.register_rwa_asset( token_address=\"0x1234567890123456789012345678901234567890\", token_id=\"123\", metadata_uri=\"https://metadata.example.com/asset/123\" ) print(f\"RWA Asset registered: {rwa_asset['asset_id']}\") print(f\"Status: {rwa_asset['status']}\") # List all RWA assets rwa_assets = client.wallets.list_rwa_assets() for asset in rwa_assets: print(f\"Asset ID: {asset['asset_id']}\") print(f\"Token Address: {asset['token_address']}\") print(f\"Token ID: {asset['token_id']}\") # Transfer RWA asset transfer_hash = client.wallets.transfer_rwa_asset( asset_id=\"rwa_asset_123\", to_address=\"0x742d35Cc6635C0532925a3b8D\" ) print(f\"RWA transfer hash: {transfer_hash}\")","title":"RWA Asset Management"},{"location":"wallets/#defi-yield-strategies","text":"","title":"DeFi Yield Strategies"},{"location":"wallets/#yield-strategy-management","text":"# Create yield strategy strategy = client.wallets.create_yield_strategy( asset_key=\"USDC_BALANCE\", protocol=\"aave\", min_apr=Decimal(\"5.0\") # 5% minimum APR ) print(f\"Strategy ID: {strategy['strategy_id']}\") print(f\"Protocol: {strategy['protocol']}\") print(f\"Target APR: {strategy['target_apr']}\") # List all yield strategies strategies = client.wallets.list_yield_strategies() for strategy in strategies: print(f\"Strategy: {strategy['strategy_id']}\") print(f\"Asset: {strategy['asset_key']}\") print(f\"Current APR: {strategy['current_apr']}\") # Execute yield strategy execution_result = client.wallets.run_yield_strategy(\"strategy_123\") print(f\"Execution status: {execution_result['status']}\") print(f\"Amount deployed: {execution_result['amount_deployed']}\")","title":"Yield Strategy Management"},{"location":"wallets/#event-monitoring","text":"","title":"Event Monitoring"},{"location":"wallets/#blockchain-event-subscriptions","text":"# Subscribe to blockchain events subscription_id = client.wallets.subscribe_event( chain=\"ethereum\", filter_criteria={ \"address\": \"0x1234567890123456789012345678901234567890\", \"topics\": [\"Transfer(address,address,uint256)\"] }, callback_url=\"https://your-webhook.com/events\" ) print(f\"Subscription ID: {subscription_id}\") # List active subscriptions subscriptions = client.wallets.list_event_subscriptions() for sub in subscriptions: print(f\"Subscription: {sub['subscription_id']}\") print(f\"Chain: {sub['chain']}\") print(f\"Status: {sub['status']}\") # Unsubscribe from events client.wallets.unsubscribe_event(subscription_id)","title":"Blockchain Event Subscriptions"},{"location":"wallets/#agent-wallets-smart-contract-wallets","text":"","title":"Agent Wallets (Smart Contract Wallets)"},{"location":"wallets/#deploy-and-manage-agent-wallets","text":"# Deploy new agent wallet agent_wallet = client.wallets.deploy_agent_wallet() print(f\"Agent wallet address: {agent_wallet['address']}\") print(f\"Deployment hash: {agent_wallet['deployment_hash']}\") # List all agent wallets agent_wallets = client.wallets.list_agent_wallets() for wallet in agent_wallets: print(f\"Address: {wallet['address']}\") print(f\"Owner: {wallet['owner']}\") print(f\"Threshold: {wallet['threshold']}\") # Get specific agent wallet details wallet_details = client.wallets.get_agent_wallet(\"0x1234567890123456789012345678901234567890\") print(f\"Spending limits: {wallet_details['spending_limits']}\") print(f\"Whitelist: {wallet_details['whitelist']}\")","title":"Deploy and Manage Agent Wallets"},{"location":"wallets/#agent-wallet-configuration","text":"# Set spending limits limit_hash = client.wallets.set_spending_limit( address=\"0x1234567890123456789012345678901234567890\", token=\"0xA0b86a33E6c3b\", # USDC amount=1000, # 1000 USDC period=86400 # 24 hours ) # Update whitelist whitelist_hash = client.wallets.update_whitelist( address=\"0x1234567890123456789012345678901234567890\", target=\"0x742d35Cc6635C0532925a3b8D\", allowed=True ) # Set multi-sig threshold threshold_hash = client.wallets.set_threshold( address=\"0x1234567890123456789012345678901234567890\", new_threshold=2 # Require 2 signatures )","title":"Agent Wallet Configuration"},{"location":"wallets/#agent-wallet-transactions","text":"# List wallet transactions transactions = client.wallets.list_wallet_transactions( address=\"0x1234567890123456789012345678901234567890\" ) for tx in transactions: print(f\"Hash: {tx['hash']}\") print(f\"To: {tx['to']}\") print(f\"Value: {tx['value']}\") print(f\"Status: {tx['status']}\")","title":"Agent Wallet Transactions"},{"location":"wallets/#account-abstraction-erc-4337","text":"","title":"Account Abstraction (ERC-4337)"},{"location":"wallets/#user-operations","text":"# Send user operation user_op = { \"sender\": \"0x1234567890123456789012345678901234567890\", \"nonce\": \"0x1\", \"initCode\": \"0x\", \"callData\": \"0xa9059cbb000000000000000000000000742d35cc6635c0532925a3b8d00000000000000000000000000000000000000000000000000000000000000064\", \"callGasLimit\": \"0x5208\", \"verificationGasLimit\": \"0x186a0\", \"preVerificationGas\": \"0x5208\", \"maxFeePerGas\": \"0x77359400\", \"maxPriorityFeePerGas\": \"0x77359400\", \"paymasterAndData\": \"0x\", \"signature\": \"0x...\" } result = client.wallets.send_user_operation( user_op=user_op, entry_point_address=\"0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789\" ) print(f\"User operation hash: {result['userOpHash']}\") # Check user operation status status = client.wallets.get_user_operation_status(result['userOpHash']) print(f\"Status: {status['status']}\") print(f\"Transaction hash: {status.get('transactionHash')}\")","title":"User Operations"},{"location":"wallets/#email-integration","text":"","title":"Email Integration"},{"location":"wallets/#email-account-management","text":"# List email accounts email_accounts = client.wallets.list_email_accounts() for account in email_accounts: print(f\"Account ID: {account['id']}\") print(f\"Email: {account['email_address']}\") print(f\"Provider: {account['provider']}\") # Create email account email_account = client.wallets.create_email_account( provider=\"gmail\", email_address=\"user@gmail.com\", config={ \"refresh_token\": \"your_refresh_token\", \"client_id\": \"your_client_id\", \"client_secret\": \"your_client_secret\" } ) # Get specific email account account = client.wallets.get_email_account(\"account_123\") print(f\"Email: {account['email_address']}\") print(f\"Status: {account['status']}\") # Update email account updated_account = client.wallets.update_email_account( account_id=\"account_123\", provider=\"gmail\", email_address=\"updated@gmail.com\", config={\"refresh_token\": \"new_refresh_token\"} ) # Refresh email token refreshed = client.wallets.refresh_email_token(\"account_123\") print(f\"Token refreshed: {refreshed['success']}\") # Delete email account client.wallets.delete_email_account(\"account_123\")","title":"Email Account Management"},{"location":"wallets/#advanced-wallet-workflows","text":"","title":"Advanced Wallet Workflows"},{"location":"wallets/#multi-chain-portfolio-management","text":"def manage_multi_chain_portfolio(client): \"\"\"Manage assets across multiple chains\"\"\" # Create wallets on different chains chains = [\"ethereum\", \"polygon\", \"arbitrum\"] wallets = {} for chain in chains: wallet = client.wallets.create_wallet(chain=chain) wallets[chain] = wallet print(f\"Created {chain} wallet: {wallet['address']}\") # Check balances across all chains portfolio = {} for chain, wallet in wallets.items(): try: balance = client.wallets.get_balance(chain, wallet['address']) portfolio[chain] = balance except Exception as e: print(f\"Error getting {chain} balance: {e}\") portfolio[chain] = 0 return portfolio # Usage portfolio = manage_multi_chain_portfolio(client) print(f\"Portfolio balances: {portfolio}\")","title":"Multi-Chain Portfolio Management"},{"location":"wallets/#automated-yield-farming","text":"def setup_yield_farming(client, asset_allocation): \"\"\"Setup automated yield farming across protocols\"\"\" strategies = [] for asset, config in asset_allocation.items(): try: strategy = client.wallets.create_yield_strategy( asset_key=asset, protocol=config[\"protocol\"], min_apr=config[\"min_apr\"] ) strategies.append(strategy) # Execute strategy immediately if configured if config.get(\"auto_execute\", False): result = client.wallets.run_yield_strategy(strategy['strategy_id']) print(f\"Executed strategy {strategy['strategy_id']}: {result['status']}\") except Exception as e: print(f\"Failed to create strategy for {asset}: {e}\") return strategies # Usage allocation = { \"USDC_BALANCE\": { \"protocol\": \"aave\", \"min_apr\": Decimal(\"4.0\"), \"auto_execute\": True }, \"ETH_BALANCE\": { \"protocol\": \"compound\", \"min_apr\": Decimal(\"3.5\"), \"auto_execute\": False } } strategies = setup_yield_farming(client, allocation)","title":"Automated Yield Farming"},{"location":"wallets/#smart-contract-interaction","text":"def deploy_and_configure_agent_wallet(client, config): \"\"\"Deploy and fully configure an agent wallet\"\"\" # Deploy agent wallet wallet = client.wallets.deploy_agent_wallet() address = wallet['address'] print(f\"Deployed agent wallet: {address}\") # Configure spending limits for token, limit_config in config['spending_limits'].items(): client.wallets.set_spending_limit( address=address, token=token, amount=limit_config['amount'], period=limit_config['period'] ) # Setup whitelist for target in config['whitelist']: client.wallets.update_whitelist( address=address, target=target, allowed=True ) # Set multi-sig threshold if config.get('threshold'): client.wallets.set_threshold(address, config['threshold']) return wallet # Usage wallet_config = { \"spending_limits\": { \"0xA0b86a33E6c3b\": {\"amount\": 1000, \"period\": 86400}, # USDC daily limit \"0x0000000000000000000000000000000000000000\": {\"amount\": 1, \"period\": 86400} # ETH daily limit }, \"whitelist\": [ \"0x742d35Cc6635C0532925a3b8D\", \"0x1234567890123456789012345678901234567890\" ], \"threshold\": 2 } agent_wallet = deploy_and_configure_agent_wallet(client, wallet_config)","title":"Smart Contract Interaction"},{"location":"wallets/#error-handling-and-best-practices","text":"","title":"Error Handling and Best Practices"},{"location":"wallets/#transaction-safety","text":"def safe_token_transfer(client, wallet_id, token_address, to_address, amount): \"\"\"Safely execute token transfer with checks\"\"\" try: # Check balance first balance = client.wallets.get_token_balance(wallet_id, token_address) if balance['balance'] < amount: return {\"success\": False, \"error\": \"Insufficient balance\"} # Execute transfer result = client.wallets.transfer_tokens( wallet_id=wallet_id, token_address=token_address, to_address=to_address, amount=amount ) return {\"success\": True, \"transaction_hash\": result['transaction_hash']} except Exception as e: return {\"success\": False, \"error\": str(e)} # Usage result = safe_token_transfer( client, \"wallet_123\", \"0xA0b86a33E6c3b\", \"0x742d35Cc6635C0532925a3b8D\", 100.0 ) if result[\"success\"]: print(f\"Transfer successful: {result['transaction_hash']}\") else: print(f\"Transfer failed: {result['error']}\")","title":"Transaction Safety"},{"location":"wallets/#gas-optimization","text":"def optimize_gas_usage(client, operations): \"\"\"Optimize gas usage for multiple operations\"\"\" # Check gas sponsorship balance sponsorship_balance = client.wallets.get_gas_sponsorship_balance() if sponsorship_balance > 0: print(f\"Using gas sponsorship: {sponsorship_balance} available\") # Execute operations using sponsored gas for op in operations: try: if op['type'] == 'transfer': result = client.wallets.transfer_tokens(**op['params']) print(f\"Sponsored transfer: {result['transaction_hash']}\") except Exception as e: print(f\"Operation failed: {e}\") else: print(\"No gas sponsorship available, using regular gas\") # Execute operations normally # Usage operations = [ { \"type\": \"transfer\", \"params\": { \"wallet_id\": \"wallet_123\", \"token_address\": \"0xA0b86a33E6c3b\", \"to_address\": \"0x742d35Cc6635C0532925a3b8D\", \"amount\": 50.0 } } ] optimize_gas_usage(client, operations)","title":"Gas Optimization"},{"location":"wallets/#api-reference","text":"","title":"API Reference"},{"location":"wallets/#walletsclient-methods","text":"Method Description Parameters Returns create_wallet() Create new wallet chain Dict import_wallet() Import existing wallet chain, private_key Dict list_wallets() List all wallets - List[Dict] delete_wallet() Delete wallet wallet_id None get_token_balance() Get token balance wallet_id, token_address Dict transfer_tokens() Transfer tokens wallet_id, token_address, to_address, amount Dict approve_tokens() Approve token spending wallet_id, token_address, spender_address, amount Dict get_balance() Get native currency balance chain, address Decimal send_transaction() Send raw transaction chain, to, signed_tx str sponsor_gas() Sponsor gas fees token_address, amount str get_gas_sponsorship_balance() Get sponsorship balance - Decimal create_onramp_session() Create fiat onramp currency, amount Dict get_onramp_status() Check onramp status session_id Dict register_rwa_asset() Register RWA asset token_address, token_id, metadata_uri Dict list_rwa_assets() List RWA assets - List[Dict] transfer_rwa_asset() Transfer RWA asset asset_id, to_address str create_yield_strategy() Create yield strategy asset_key, protocol, min_apr Dict list_yield_strategies() List yield strategies - List[Dict] run_yield_strategy() Execute yield strategy strategy_id Dict subscribe_event() Subscribe to events chain, filter_criteria, callback_url str list_event_subscriptions() List subscriptions - List[Dict] unsubscribe_event() Unsubscribe from events subscription_id None deploy_agent_wallet() Deploy agent wallet - Dict list_agent_wallets() List agent wallets - List[Dict] get_agent_wallet() Get agent wallet details address Dict set_spending_limit() Set spending limit address, token, amount, period str update_whitelist() Update whitelist address, target, allowed str set_threshold() Set multi-sig threshold address, new_threshold str list_wallet_transactions() List wallet transactions address List[Dict] send_user_operation() Send user operation user_op, entry_point_address Dict get_user_operation_status() Get user op status user_op_hash Dict","title":"WalletsClient Methods"}]}